"""
sess_plot_util.py

This module contains basic functions for plotting with pyplot data generated by 
the Allen Institute OpenScope experiments for the Credit Assignment Project.

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 3.7.

"""

import copy
import os

import itertools
import matplotlib as mpl
from matplotlib import colors as mplcol
from matplotlib import pyplot as plt
import numpy as np

from util import gen_util, logger_util, math_util, plot_util
from sess_util import sess_str_util


#############################################
def init_figpar(ncols=4, sharex=False, sharey=True, subplot_hei=7, 
                subplot_wid=7, datetime=True, use_dt=None, fig_ext="svg", 
                overwrite=False, runtype="prod", output=".", plt_bkend=None, 
                linclab=True, fontdir=None):
    
    """
    Returns a dictionary containing figure parameter dictionaries for 
    initializing a figure, saving a figure, and extra save directory 
    parameters.

    Optional args: 
        - ncols (int)      : number of columns in the figure
                             default: 4 
        - sharex (bool)    : if True, x axis lims are shared across subplots
                             default: False 
        - sharey (bool)    : if True, y axis lims are shared across subplots
                             default: True
        - subplot_hei (num): height of each subplot (inches)
                             default: 7
        - subplot_wid (num): width of each subplot (inches)
                             default: 7
        - datetime (bool)  : if True, figures are saved in a subfolder named 
                             based on the date and time.
        - use_dt (str)     : datetime folder to use
                             default: None
        - fig_ext (str)    : figure extension
                             default: "svg"
        - overwrite (bool) : if False, overwriting existing figures is 
                             prevented by adding suffix numbers.
                             default: False
        - runtype (str)    : runtype ("pilot", "prod")
                             default: "prod"
        - output (str)     : general directory in which to save output
                             default: "."
        - plt_bkend (str)  : mpl backend to use for plotting (e.g., "agg")
                             default: None
        - linclab (bool)   : linclab style setting 
                             default: None
        - fontdir (str)    : path to directory where additional fonts are stored
                             default: None

    Returns:
        - figpar (dict): dictionary containing figure parameters:
            ["init"] : dictionary containing the following inputs as
                       attributes:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
            ["save"] : dictionary containing the following inputs as
                       attributes:
                           datetime, use_dt, fig_ext, overwrite
            ["dirs"]: dictionary containing the following attributes:
                ["figdir"] (str)   : main folder in which to save figures
                ["roi"] (str)      : subdirectory name for ROI analyses
                ["run"] (str)      : subdirectory name for running analyses
                ["acr_sess"] (str) : subdirectory name for analyses across 
                                     sessions
                ["autocorr"] (str) : subdirectory name for autocorrelation 
                                     analyses
                ["colormaps"] (str): subdirectory name for colormap 
                                     analyses
                ["dir_idx"] (str)  : subdirectory name for direction index 
                                     analyses
                ["full"] (str)     : subdirectory name for full trace plots
                ["glm"] (str)      : subdirectory name for glm plots
                ["grped"] (str)    : subdirectory name for ROI grps data
                ["lat"] (str)      : subdirectory name for latency analyses
                ["locori"] (str)   : subdirectory name for location and 
                                     orientation responses
                ["mags"] (str)     : subdirectory name for magnitude analyses
                ["posori"] (str)   : subdirectory name for position and 
                                     orientation plots
                ["prog"] (str)     : subdirectory name for firsts progression 
                                     analysis                
                ["prop"] (str)     : subdirectory name for proportion 
                                     responsive ROI analyses
                ["pupil"] (str)    : subdirectory for pupil analyses
                ["oridir"] (str)   : subdirectory name for 
                                     orientation/direction analyses
                ["surp_qu"] (str)  : subdirectory name for surprise, quintile 
                                     analyses
                ["surp_idx"] (str) : subdirectory name for surprise index 
                                     analyses
                ["tune_curv"] (str): subdirectory name for tuning curves
                
            ["mng"]: dictionary containing the following attributes:
                ["plt_bkend"] (str): mpl backend to use
                ["linclab"] (bool) : if True, Linclab mpl defaults are used
                ["fontdir"] (str)  : path to directory containing additional 
                                     fonts
    """

    fig_init = {"ncols"      : ncols,
                "sharex"     : sharex,
                "sharey"     : sharey, 
                "subplot_hei": subplot_hei,
                "subplot_wid": subplot_wid
                }

    fig_save = {"datetime" : datetime,
                "use_dt"   : use_dt,
                "fig_ext"  : fig_ext,
                "overwrite": overwrite
                }
    
    fig_mng = {"linclab"  : linclab,
               "plt_bkend": plt_bkend,
               "fontdir"  : fontdir,
                }

    figdir = os.path.join(output, "results", "figures")

    fig_dirs = {"figdir"   : figdir,
                "roi"      : os.path.join(figdir, f"{runtype}_roi"),
                "run"      : os.path.join(figdir, f"{runtype}_run"),
                "acr_sess" : "acr_sess",
                "autocorr" : "autocorr",
                "colormaps": "cms",
                "dir_idx"  : "dir_idx",
                "full"     : "full",
                "glm"      : "glm",
                "grped"    : "grped",
                "lat"      : "latencies",
                "mags"     : "mags",
                "posori"   : "posori",
                "prog"     : "prog",
                "prop"     : "prop_resp",
                "pupil"    : "pupil",
                "oridir"   : "oridir",
                "surp_idx" : "surp_idx",
                "surp_qu"  : "surp_qu",
                "tune_curv": "tune_curves",
               }

    figpar = {"init" : fig_init,
              "save" : fig_save,
              "dirs" : fig_dirs,
              "mng"  : fig_mng
              }
    
    return figpar


#############################################
def get_quint_cols(n_quints=4):
    """
    get_quint_cols()

    Returns regular and surprise colors for quintiles, as well as label colors
    for regular and surprise.

    Required args:
        - n_quints (int): number of quintiles

    Returns:
        - cols (list)    : nested list of colors, 
                           structured as [regular, surprise]
        - lab_cols (list): label colors for regular and surprise data
    """

    col_reg  = plot_util.get_color_range(n_quints, "blue")
    col_surp = plot_util.get_color_range(n_quints, "red")

    lab_reg = plot_util.get_color_range(1, "blue")[0]
    lab_surp = plot_util.get_color_range(1, "red")[0]

    cols = [col_reg, col_surp]
    lab_cols = [lab_reg, lab_surp]

    return cols, lab_cols


#############################################
def get_axislabels(fluor="dff", area=False, scale=False, datatype="roi", 
                   x_ax=None, y_ax=None):
    """
    get_axislabels()

    Returns appropriate labels for x and y axes. 
    
    If y_ax is None, y axis is assumed to be fluorescence, and label is 
    inferred from fluor and dff parameters. If x_ax is None, x axis is assumed
    to be time in seconds.

    Optional args:
        - fluor (str)     : if y_ax is None, whether "raw" or processed 
                            fluorescence traces "dff" are plotted. 
                            default: "dff"
        - area (bool)     : if True, "area" is added after the y_ax label
                            default: False
        - scale (bool)    : if True, "(scaled)" is added after the y_ax label
                            default: False
        - datatype (str)  : type of data, either "run" or "roi"
                            default: "roi"
        - x_ax (str)      : label to use for x axis.
                            default: None
        - y_ax (str)      : label to use for y axis.
                            default: None

    Returns:
        - x_str (str): X axis label
        - y_str (str): Y axis label
    """

    area_str = ""
    if area:
        area_str = " area"

    scale_str = ""
    if scale:
        scale_str = " (scaled)"

    if x_ax is None:
        x_str = "Time (s)"
    else:
        x_str = x_ax

    if y_ax is None:
        if datatype == "roi":
            y_str = sess_str_util.fluor_par_str(fluor, str_type="print")
        elif datatype == "run":
            y_str = "Running velocity (cm/s)"
        else:
            gen_util.accepted_values_error("datatype", datatype, ["roi", "run"])
    else:
        y_str = y_ax

    y_str = u"{}{}{}".format(y_str, area_str, scale_str)

    return x_str, y_str


#############################################
def add_axislabels(sub_ax, fluor="dff", area=False, scale=False, datatype="roi", 
                   x_ax=None, y_ax=None, first_col=True, last_row=True):
    """
    add_axislabels(sub_ax)

    Adds the appropriate labels to the subplot x and y axes. 
    (See get_axislabel())
    
    Required args:
        - sub_ax (plt Axis subplot): subplot

    Optional args:
        - fluor (str)     : if y_ax is None, whether "raw" or processed 
                            fluorescence traces "dff" are plotted. 
                            default: "dff"
        - area (bool)     : if True, "area" is added after the y_ax label
                            default: False
        - scale (bool)    : if True, "(scaled)" is added after the y_ax label
                            default: False
        - datatype (str)  : type of data, either "run" or "roi"
                            default: "roi"
        - x_ax (str)      : label to use for x axis.
                            default: None
        - y_ax (str)      : label to use for y axis.
                            default: None
        - first_col (bool): if True, only add an y axis label to subplots in 
                            first column
                            default: True
        - last_row (bool) : if True, only add an x axis label to subplots in 
                            last row
                            default: True
    """

    x_str, y_str = get_axislabels(fluor, area, scale, datatype, x_ax, y_ax)

    if not(last_row) or sub_ax.is_last_row():
        sub_ax.set_xlabel(x_str)

    if not(first_col) or sub_ax.is_first_col():
        sub_ax.set_ylabel(y_str)


#############################################
def get_fr_lab(plot_vals="both", op="diff", start_fr=-1):
    """
    get_fr_lab()

    Returns a list of labels for gabor frames based on values that are plotted,
    and operation on surprise v no surprise, starting with grayscreen (G).

    Optional args:
        - plot_vals (str): values plotted ("surp", "reg", "both")
                           default: "both"
        - op (str)       : operation on the values, if both ("ratio" or "diff")
                           default: "diff"
        - start_fr (int) : starting gabor frame 
                           (-1: G, 0: A, 1: B, 2:C, 3:D/U)
                           default: -1
    
    Returns:
        - labels (list)  : list of labels for gabor frames
    """

    labels = ["G", "A", "B", "C"]

    if plot_vals == "surp":
        labels.extend(["U"])
    elif plot_vals == "reg":
        labels.extend(["D"])
    elif plot_vals == "both":
        if op == "diff":
            labels.extend(["U-D"])      
        elif op == "ratio":
            labels.extend(["U/D"])
        else:
            gen_util.accepted_values_error("op", op, ["diff", "ratio"])
    else:
        gen_util.accepted_values_error(
            "plot_vals", plot_vals, ["both", "reg", "surp"])

    if start_fr != -1:
        labels = list(np.roll(labels, -(start_fr+1)))

    return labels


#############################################
def get_seg_comp(gabfr=0, plot_vals="both", op="diff", pre=0, post=1.5):
    """
    get_seg_comp()

    Returns lists with different components needed when plotting segments, 
    namely positions of labels, ordered labels, positions of heavy bars and 
    position of regular bars.

    Optional args:
        - gabfr (int)    : gabor frame of reference
                           default: 0
        - plot_vals (str): values plotted ("surp", "reg", "both")
                           default: "both"
        - op (str)       : operation on the values, if both ("ratio" or "diff")
                           default: "diff"
        - pre (num)      : range of frames to include before reference frame 
                           (in s)
                           default: 0 (only value implemented)
        - post (num)     : range of frames to include after reference frame
                           (in s)
                           default: 1.5 (only value implemented)
    
    Returns:
        - xpos (list)          : list of x coordinates at which to add labels
                                 (same length as labels)
        - labels (list)         : ordered list of labels for gabor frames
        - hbars (list or float): list of x coordinates at which to add 
                                 heavy dashed vertical bars
        - bars (list or float) : list of x coordinates at which to add 
                                 dashed vertical bars
    """

    if gabfr not in list(range(0, 4)):
        raise ValueError("Gabor frame must be 0, 1, 2 or 3.")

    seg_len = 0.3

    pre_segs = int(np.floor(pre/seg_len)) # number of segs pre
    n_segs = int(np.floor((pre + post)/seg_len)) # number of segs
    xpos = [(x + 0.5 - pre_segs) * seg_len for x in range(n_segs)]
    bars = [(x - pre_segs) * seg_len for x in range(n_segs)]
    
    labels = get_fr_lab(plot_vals, op, gabfr - pre_segs)
    if len(labels) < len(xpos):
        labels = labels * (len(xpos)//len(labels) + 1)
    if len(labels) > len(xpos):
        labels = labels[:len(xpos)]

    hbars = [bars[x] for x in range(1, len(bars)) if labels[x-1] == "C"]
    bars = gen_util.remove_if(bars, [-pre] + hbars)
    hbars = gen_util.remove_if(hbars, -pre)

    return xpos, labels, hbars, bars


#############################################
def plot_labels(ax, gabfr=0, plot_vals="both", op="none", pre=0, post=1.5, 
                cols=None, sharey=True, t_heis=[0.85, 0.75], incr=True, 
                omit_empty=True, **axline_kw):
    """
    plot_labels(ax)

    Plots lines and labels for gabors segments.
   
    Required args:
        - ax (plt Axis): axis

    Optional args:
        - gabfr (int)      : gabor frame of reference
                             default: 0
        - plot_vals (str)  : values plotted ("surp", "reg", "both")
                             default: "both"
        - op (str)         : operation on the values, if both ("ratio" or "diff")
                             default: "none"
        - pre (num)        : range of frames to include before reference frame 
                             (in s)
                             default: 0 (only value implemented)
        - post (num)       : range of frames to include after reference frame
                             (in s)
                             default: 1.5 (only value implemented)
        - cols (str)       : colors to use for labels
                             default: None
        - sharey (bool)    : if True, y axes are shared
                             default: True
        - t_heis (list)    : height(s) at which to place labels. If t_hei 
                             includes negative values, the ylims are not 
                             modified.
                             default: [0.85, 0.75]
        - incr (bool)      : if True, y axis limits are increased to accomodate
                             labels
                             default: True
        - omit_empty (bool): if True, no labels are added to subplots with no 
                             lines plotted
                             default: True 

    Kewyord args:
        - axline_kw (dict): keyword arguments for plot_util.add_bars 
                            (-> plt.axvline() or plt.axhline())
    """

    t_heis = gen_util.list_if_not(t_heis)
    if cols is None:
        cols = ["k", "k"]

    min_t_hei = min(t_heis)
    if min_t_hei > 0:
        plot_util.incr_ymax(ax, incr=1.05/min_t_hei, sharey=sharey)

    if plot_vals == "both":
        if op == "none":
            plot_vals = ["reg", "surp"]

    plot_vals = gen_util.list_if_not(plot_vals)

    n_ax = np.product(ax.shape)
    for i in range(n_ax):
        sub_ax = plot_util.get_subax(ax, i)
        if omit_empty and len(sub_ax.lines) == 0:
            continue
        for i, pv in enumerate(plot_vals):
            [xpos, lab, h_bars, seg_bars] = get_seg_comp(
                gabfr, pv, op, pre, post)
            plot_util.add_labels(sub_ax, lab, xpos, t_heis[i], cols[i])
        plot_util.add_bars(sub_ax, hbars=h_bars, bars=seg_bars, **axline_kw)


#############################################
def plot_gabfr_pattern(sub_ax, x_ran, alpha=0.1, offset=0, bars_omit=[], 
                       shade_col="k", shade_lim="all"):
    """
    plot_gabfr_pattern(sub_ax, x_ran)

    Plots light dashed lines at the edges of each gabor sequence (end of 
    grayscreen (G)) and shades D/U segments.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - x_ran (array-like)       : range of x axis values 
                                     (or at least [min, max])

    Optional args:
        - alpha (num)     : plt alpha variable controlling shading 
                            transparency (from 0 to 1)
                            default: 0.1
        - offset (num)    : offset of sequence start from 0 in segs 
                            (start gabor frame number)
                            default: 0
        - bars_omit (list): positions at which to omit bars (e.g., in case they 
                            would be redundant)
                            default: []
        - shade_col (str) : D/U shading colour (none, if "none")
                            default: "k"
        - shade_lim (str) : how to limit shading 
                            "all": no limits within x_ran
                            "neg": only within x_ran =< 0
                            "pos": only within x_ran >= 0
                            default: "all"
    """

    offset_s = np.round(0.3 * offset, 10) # avoid periodic values

    x_min, x_max = [np.min(x_ran), np.max(x_ran)]
    bars = plot_util.get_repeated_bars(x_min, x_max, 1.5, 
        offset=-offset_s) # sequence start/end
    bars = gen_util.remove_if(bars, bars_omit + [x_min, x_max])
    plot_util.add_bars(sub_ax, bars=bars)

    sh_min, sh_max = x_min, x_max
    if shade_lim == "pos":
        sh_min = np.max([sh_min, 0])
    elif shade_lim == "neg":
        sh_max = np.min([sh_max, 0])
    elif shade_lim != "all":
        gen_util.accepted_values_error(
            "shade_lim", shade_lim, ["all", "pos", "neg"])

    shade_wid = 0.3
    # get the extended shade starts
    ext_shade_st = plot_util.get_repeated_bars(
        sh_min - shade_wid, sh_max + shade_wid, 1.5, 
        offset=-offset_s - 0.6) # surprise start

    shade_st = []
    shade_end = []
    for st in ext_shade_st:
        end = st + shade_wid
        if st < sh_min:
            st = sh_min
        if end > sh_max:
            end = sh_max
        if end > st:
            shade_st.append(st)
            shade_end.append(end)

    if len(shade_st) != 0 and shade_col not in ["None", "none"]:
        plot_util.add_vshade(
            sub_ax, shade_st, shade_end, alpha=alpha, color=shade_col)


#############################################
def get_gab_time_xticks(xran, lock=False):
    """
    get_gab_time_xticks(xran)

    Returns xtick values for Gabor response traces.

    Required args:
        - xran (array-like): x-values for the data, or at least the [min, max]

    Optional args:
        - lock (bool): if True, xran is replicated in the negative
                       default: False
    """
    step = 0.15
    max_tick = int(np.ceil(np.max(xran)/step)) * step
    if lock:
        min_tick = - max_tick
        if min_tick > max_tick:
            raise ValueError("If 'lock' is True, 'xran' should be positive.")
    else:
        min_tick = int(np.min(xran)/step) * step
    if max_tick - min_tick == 0:
        n_ticks = 1
    else:
        n_ticks = int((max_tick - min_tick)/step)
        n_tick_vals = math_util.get_divisors(n_ticks, min_val=2, max_val=5)
        n_ticks = 6 if len(n_tick_vals) == 0 else n_tick_vals[-1] + 1
    xticks = np.linspace(min_tick, max_tick, n_ticks)

    if len(xticks) > 1:
        diff = np.min(np.diff(xticks))
        n_dig = - np.floor(np.log10(np.absolute(diff))).astype(int) + 1
        xticks = [np.around(v, n_dig) for v in xticks]
    
    return xticks


#############################################
def update_plt_linpla():
    """
    update_plt_linpla()

    Updates rcParams for plane x line olots.
    """

    plt.rcParams.update({
        "lines.linewidth"      : 5.0, 
        "patch.linewidth"      : 5.0, 
        "axes.linewidth"       : 4.0, 
        "xtick.major.width"    : 4.0, 
        "ytick.major.width"    : 4.0, 
        "lines.markeredgewidth": 4.0, 
        "legend.fontsize"      : "large"
        })
        
    return


#############################################
def fig_init_linpla(figpar=None, kind="reg", n_sub=1, sharey=False, 
                    sharex=True):
    """
    fig_init_linpla()

    Returns figpar dictionary with initialization parameters modified for
    graphs across sessions divided by line/plane combinations.

    Optional args:
        - figpar (dict)       : dictionary containing figure parameters 
                                (initialized if None):
            ["init"] : dictionary containing the following inputs as
                       attributes:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
                                default: None
        - kind (str)          : kind of plot 
                                "reg" for single plot per layer/line, 
                                "traces" for traces plot per session (rows), 
                                "prog" for progression plot per session (cols), 
                                "idx" for surprise index plot per session (rows)
                                default: "reg"
        - n_sub (int)         : number of subplots per line/plane combination
                                default: 1
        - sharey (bool)       : y-axis sharing parameter
                                default: False
        - sharex (bool)       : x-axis sharing parameter
                                default: True

    Returns:
        - figpar (dict): dictionary containing figure parameters:
            ["init"] : dictionary containing the following inputs modified:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
    """

    figpar = copy.deepcopy(figpar)

    if figpar is None:
        figpar = init_figpar()

    if "init" not in figpar.keys():
        raise ValueError("figpar should have 'init' subdictionary.")

    if sharey in [False, "rows"]:
        wspace = 0.5
    else:
        wspace = 0.2

    ncols = 2
    if kind == "traces":
        wid = 3.3
        hei = np.max([wid/n_sub * 1.15, 1.0])
    elif kind == "prog":
        ncols *= n_sub
        wid = np.max([9.0/n_sub, 3.0])
        hei = 2.0
    elif kind == "idx":
        wid = 5
        hei = np.max([wid * 1.5/n_sub, 1.0])
    else:
        wid = 2.5
        hei = 4.3
        figpar["init"]["gs"] = {"hspace": 0.15, "wspace": wspace}

    figpar["init"]["ncols"] = ncols
    figpar["init"]["subplot_hei"] = hei
    figpar["init"]["subplot_wid"] = wid
    figpar["init"]["sharex"] = sharex
    figpar["init"]["sharey"] = sharey

    return figpar


#############################################
def fig_linpla_pars(n_sess=False, n_grps=None):
    """
    fig_linpla_pars()

    Returns parameters for a line/plane combination graph.

    Optional args:
        - n_sess (bool or int): if not False, provides number of sessions 
                                plotted separately per line/plane combination 
                                and used in multiplying number of plots
                                default: False
        - n_grps (int or None): if not None, the number of groups in the data 
                                is verified against the expected number of 
                                groups
                                default: None

    Returns:
        - lines (list)        : ordered list of lines
        - planes (list)       : ordered list of planes
        - linpla_iter (list)  : ordered list of lines and planes, structured as 
                                grp x [lin, pla]
        - pla_cols (list)     : colors for each plane
        - pla_col_names (list): color names for each plane
        - n_plots (int)       : total number of plots
    """

    lines, planes = ["L2/3", "L5"], ["dendrites", "somata"]
    linpla_iter = [[lin, pla] for lin in lines for pla in planes]
    pla_col_names = ["green", "blue"]
    pla_cols = [plot_util.get_color(c, ret="single") for c in pla_col_names]
    
    if n_sess:
        mult = n_sess
    else:
        mult = 1
    n_plots = len(lines) * len(planes) * mult

    if n_grps is not None and n_grps > n_plots/mult:
        raise ValueError(f"Expected up to {n_plots} line x plane "
            f"combinations, not {n_grps}.")

    return lines, planes, linpla_iter, pla_cols, pla_col_names, n_plots


#############################################
def adjust_linpla_y_axis_sharing(ax, kind="reg"):
    """
    adjust_linpla_y_axis_sharing(ax)

    If no y axes are shared, sets y-axes belonging to the same plane/line group 
    to be shared, and updates axis scaling.

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows), 
                             "prog" for progression plot per session (cols), 
                             "idx" for surprise index plot per session (rows)
                             default: "reg"
    """

    # check whether any y axes are shared
    set_sharey = (len(plot_util.get_shared_axes(ax, axis="y")) == 0)

    if kind == "reg" or not set_sharey:
        return

    n_rows, n_cols = ax.shape
    to_share = []
    if kind in ["traces", "idx"]:
        if n_rows % 2 != 0:
            raise ValueError("Expected even number of rows")
        row_per_grp = int(n_rows/2)
        if row_per_grp > 1:
            to_share = [[ax[i * row_per_grp + r, c] 
                for r in range(row_per_grp)] 
                for i in range(2) for c in range(2)]
    elif kind == "prog":
        if n_cols % 2 != 0:
            raise ValueError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
        if col_per_grp > 1:
            to_share = [[ax[r, i * col_per_grp + c] 
                for c in range(col_per_grp)] 
                for i in range(2) for r in range(2)]
    else:
        gen_util.accepted_values_error(
            "kind", kind, ["reg", "traces", "prog", "idx"])

    for axis_set in to_share:
        plot_util.set_shared_axes(axis_set, "y")
        if kind in ["traces", "idx"]:
            remove_labs = axis_set[:-1]
        elif kind == "prog":
            remove_labs = axis_set[1:]
        for subax in remove_labs:
            subax.tick_params(axis="y", labelleft=False)

    for sub_ax in ax.reshape(-1):
       sub_ax.autoscale()

    return


#############################################
def get_yticklabel_info(ax, kind="reg"):
    """
    get_yticklabel_info(ax)

    Returns information on how to label y axes.

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows), 
                             "prog" for progression plot per session (cols), 
                             "idx" for surprise index plot per session (rows)

    Returns:
        - add_yticks (list) : list of subplots that should have ytick labels
        - move_ylabel (bool): if True, y axis label should be shifted over
    """

    # establish which subplots should have y tick labels
    axgrps = plot_util.get_shared_axes(ax, axis="y")
    if len(axgrps) == 4: # sharing by group
        add_idx = -1
        move_ylabel = (np.min([len(grp) for grp in axgrps]) == 1)
        if kind == "prog":
            add_idx = 0
            move_ylabel = True
        add_yticks = [axg[add_idx] for axg in axgrps]

    elif len(axgrps) == 0: # no sharing
        add_yticks = ax.reshape(-1)
        move_ylabel = True
    elif len(axgrps) == 1: # all sharing
        add_yticks = ax[-1, 0:]
        move_ylabel = False
    elif len(axgrps) == ax.shape[0]: # sharing by row
        add_yticks = ax[:, 0].reshape(-1)
        move_ylabel = True
    else:
        raise NotImplementedError(f"Condition for {len(axgrps)} subplots in "
            "shared axis groups not implemented.")

    return add_yticks, move_ylabel


#############################################
def add_linpla_axislabels(ax, fluor="dff", area=False, scale=False, 
                          datatype="roi", x_ax=None, y_ax=None, 
                          single_lab=False, kind="reg"):
    """
    add_linpla_axislabels(ax)

    Adds the appropriate axis labels to the figure axes. 
    (See get_axislabel() for label content)

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - fluor (str)      : if y_ax is None, whether "raw" or processed 
                             fluorescence traces "dff" are plotted. 
                             default: "dff"
        - area (bool)      : if True, "area" is added after the y_ax label
                             default: False
        - scale (bool)     : if True, "(scaled)" is added after the y_ax label
                             default: False
        - datatype (str)   : type of data, either "run" or "roi"
                             default: "roi"
        - x_ax (str)       : label to use for x axis.
                             default: None
        - y_ax (str)       : label to use for y axis.
                             default: None
        - single_lab (bool): if True, y label only added to top, left of each 
                             subplot group sharing y axis, and x label only 
                             added to bottom, middle, and tick labels only 
                             added to bottom left
                             default: False
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows),  
                             "prog" for progression plot per session (cols), 
                             "idx" for surprise index plot per session (rows)
    """

    add_yticks, move_ylabel = get_yticklabel_info(ax, kind=kind)

    # get axis labels if not already provided
    x_str, y_str = get_axislabels(fluor, area, scale, datatype, x_ax, y_ax)

    fig = ax.reshape(-1)[0].figure
    n_rows, n_cols = ax.shape
    if n_rows % 2 != 0 or n_cols % 2 != 0:
        raise ValueError("Expected even number of rows and columns.")
    row_per_grp = int(n_rows/2)
    col_per_grp = int(n_cols/2)
    
    # add x label
    if single_lab:    
        if kind == "reg":
            fig_ypos = 0.02
        elif kind in ["traces", "idx"]:
            fig_ypos = -0.01
        else:
            fig_ypos = 0
        fig.text(0.5, fig_ypos, x_str, fontsize="xx-large", 
            horizontalalignment="center", weight="bold")
    else:
        for sub_ax in ax.reshape(-1):
            if sub_ax.is_last_row():
                if kind == "prog":
                    if x_str == "Sessions":
                        x_str = "Session"
                    x_pos = fig.transFigure.inverted().transform(
                        sub_ax.transAxes.transform([0.5, 0]))[0]
                    fig.text(x_pos, -0.05, x_str, fontsize="xx-large", 
                        horizontalalignment="center", weight="bold")
                else:
                    sub_ax.set_xlabel(x_str, weight="bold")

    # y labels for each plane set (top and bottom)
    add_y_pos = plot_util.get_fig_rel_pos(ax, row_per_grp, dim="y")
    if single_lab:
        add_y_pos = add_y_pos[:1] # top only

    # move labels for long y axis labels
    if (len(y_str) > 6 and kind in ["traces", "idx"] and 
        (ax.size / len(add_yticks) < 5)):
        move_ylabel = True

    y_lab_xpos = 0.02 - 0.09 * (move_ylabel or not(single_lab))
    if kind in ["traces", "idx"]:
        y_lab_xpos = 0.03 - 0.05 * (move_ylabel or not(single_lab))
    elif kind == "prog":
        y_lab_xpos = 0.01 - 0.02 * (move_ylabel or not(single_lab))

    for y_pos in add_y_pos:
        fig.text(y_lab_xpos, y_pos, y_str, rotation=90, fontsize="xx-large", 
            verticalalignment="center", weight="bold")

    # remove tick labels for all but last row and first column
    label_cols = [0]
    skip_x = False
    if kind == "prog":
        label_cols = [0, col_per_grp]
    elif kind == "idx":
        skip_x = True
        if len(plot_util.get_shared_axes(ax, axis="x")) != 1:
            skip_x = False
    if single_lab:
        for sub_ax in ax.reshape(-1):
            colNum = sub_ax.get_subplotspec().colspan.start
            if (not (sub_ax.is_last_row() and colNum in label_cols) and 
                skip_x):
                sub_ax.tick_params(labelbottom=False)
            if sub_ax not in add_yticks:
                sub_ax.tick_params(labelleft=False)


#############################################
def format_each_linpla_subaxis(ax, xticks=None, sess_ns=None, kind="reg", 
                               single_lab=True):
    """
    format_each_linpla_subaxis(ax)

    Formats each subaxis separately, specifically:
    
    - Adds session numbers if provided
    - Removes bottom lines and ticks for top plots
    - Adds x tick labels to bottom plots
    - Adds y tick labels to correct plots

    Required args:
        - ax (plt Axis): plt axis

    Optional args:
        - xticks (list)    : x tick labels (if None, none are added)
                             default: None
        - sess_ns (list)   : list of session numbers (inferred if None)
                             default: None 
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows), 
                             "prog" for progression plot per session (cols), 
                             "idx" for surprise index plot per session (rows)
                             default: "reg"
        - single_lab (bool): if True, only one set of session labels it added 
                             to the graph
                             default: True 
    """
    # make sure to autoscale subplots after this, otherwise bugs emerge
    for sub_ax in ax.reshape(-1):
        sub_ax.autoscale()

    # get information based on kind of graph
    n_rows, n_cols = ax.shape
    col_per_grp = 1
    pad_p = 0
    if kind == "reg":
        if xticks is not None:
            div = len(xticks)
            pad_p = 1.0/div
        if n_rows != 2 or n_cols != 2:
            raise ValueError("Regular plots should have 2 rows and 2 columns.")
    elif kind == "prog":
        if n_cols % 2 != 0:
            raise ValueError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
    elif kind not in ["traces", "idx"]:
        gen_util.accepted_values_error("kind", kind, ["reg", "traces", "prog"])

    for r in range(n_rows):
        for c in range(n_cols):
            sub_ax = ax[r, c]
            # set x ticks
            if xticks is not None:
                plot_util.set_ticks(sub_ax, axis="x", min_tick=min(xticks), 
                    max_tick=max(xticks), n=len(xticks), pad_p=pad_p)
                # always set ticks (even again) before setting labels
                sub_ax.set_xticklabels(xticks, weight="bold")
                # to avoid very wide plot features
                if len(xticks) == 1:
                    sub_ax.set_xlim(xticks[0] - 1, xticks[0] + 1)
            # add session numbers
            if kind in ["traces", "idx", "prog"] and sess_ns is not None :
                if kind in ["traces", "idx"] and c == 1 and r < len(sess_ns): # RIGHT
                    sess_lab = f"sess {sess_ns[r]}"
                    sub_ax.text(0.65, 0.75, sess_lab, fontsize="xx-large", 
                        transform=sub_ax.transAxes, style="italic")
                elif (kind == "prog" and sub_ax.is_last_row() and 
                    (c < len(sess_ns) or not(single_lab))): # BOTTOM
                    sub_ax.text(0.5, -0.5, sess_ns[c % len(sess_ns)], 
                        fontsize="xx-large", transform=sub_ax.transAxes, 
                        weight="bold")
            
            # remove x ticks and spines from graphs
            if not sub_ax.is_last_row() and kind != "idx": # NOT BOTTOM
                sub_ax.tick_params(axis="x", which="both", bottom=False) 
                sub_ax.spines["bottom"].set_visible(False)

            # remove y ticks and spines from graphs
            colNum = sub_ax.get_subplotspec().colspan.start
            if kind == "prog" and not colNum in [0, col_per_grp]:
                sub_ax.tick_params(axis="y", which="both", left=False) 
                sub_ax.spines["left"].set_visible(False)

            yticks = [np.around(v, 10) for v in sub_ax.get_yticks()]
            if kind in ["traces", "idx"] and len(yticks) > 3:
                max_abs = np.max(np.absolute(yticks))
                new = [-max_abs, 0, max_abs]
                yticks = list(filter(lambda x: x == 0 or x in yticks, new))

            # always set ticks (even again) before setting labels
            sub_ax.set_yticks(yticks)
            sub_ax.set_yticklabels(yticks, weight="bold")            



#############################################
def format_linpla_subaxes(ax, fluor="dff", area=False, datatype="roi", 
                          lines=None, planes=None, xlab=None, xticks=None, 
                          sess_ns=None, ylab=None, kind="reg", tight=True, 
                          modif_share=True, single_lab=True):
    """
    format_linpla_subaxes(ax)

    Formats axis labels and grids for a square of subplots, structured as 
    planes (2 or more rows) x lines (2 columns). 
    
    Specifically:
    - Adds line names to top plots
    - Adds plane information on right plots (midde of top and bottom half)

    Calls:
        - adjust_linpla_y_axis_sharing()
        - format_each_linpla_subaxis()
        - add_linpla_axislabels()

    Required args:
        - ax (plt Axis): plt axis

    Optional args:
        - fluor (str)       : if ylab is None, whether "raw" or processed 
                              fluorescence traces "dff" are plotted. 
                              default: "dff"
        - area (bool)       : if True, "area" is added after the ylab label
                              default: False
        - datatype (str)    : type of data, either "run" or "roi"
                              default: "roi"
        - lines (list)      : ordered lines (2)
                              default: None
        - planes (list)     : ordered planes (2)
                              default: None
        - xlab (str)        : x label
                              default: None
        - xticks (list)     : x tick labels (if None, none are added)
                              default: None
        - sess_ns (list)    : list of session numbers (inferred if None)
                              default: None 
        - ylab (str)        : y axis label (overrides automatic one)
                              default: None
        - kind (str)        : kind of plot 
                              "reg" for single plot per layer/line, 
                              "traces" for traces plot per session (rows), 
                              "prog" for progression plot per session (cols), 
                              "idx" for surprise index plot per session (rows)
                              default: "reg"
        - tight (bool)      : tight figure layout
                              default: True
        - modif_share (bool): if True, y axis sharing modifications are not made
                              default: True
        - single_lab (bool) : if True, where possible, duplicate labels 
                              (axes and ticks) are omitted.
                              default: True
    """
    
    if kind != "idx" and modif_share:
        adjust_linpla_y_axis_sharing(ax, kind=kind)

    format_each_linpla_subaxis(ax, xticks=xticks, sess_ns=sess_ns, kind=kind)

    # get information based on kind of graph
    n_rows, n_cols = ax.shape
    row_per_grp, col_per_grp = 1, 1
    if kind == "reg":
        fig_xpos = 0.9 # for plane names (x pos)
        n = 4
        if n_rows != 2 or n_cols != 2:
            raise ValueError("Regular plots should have 2 rows and 2 columns.")
    elif kind in ["traces", "idx"]:
        fig_xpos = 1.0 # for plane names (x pos)
        if n_rows % 2 != 0:
            raise ValueError("Expected even number of rows")
        row_per_grp = int(n_rows/2)
        n = 4
    elif kind == "prog":
        n = 3
        fig_xpos = 1.0 # for plane names (x pos)            
        if n_cols % 2 != 0:
            raise ValueError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
    else:
        gen_util.accepted_values_error(
            "kind", kind, ["reg", "traces", "prog", "idx"])

    if kind in ["reg", "prog", "idx"]:
        plot_util.set_interm_ticks(ax, n, dim="y", weight="bold", share=False)

    # get x axis label and tick information
    if kind == "traces":
        xlab = "Time (s)" if xlab is None else xlab
    elif kind == "idx":
        xlab = "Index" if xlab is None else xlab
    else:
        xlab = "Sessions" if xlab is None else xlab

    # get and check lines and planes
    if lines is None:
        lines = ["L2/3", "L5"]
    if planes is None:
        planes = ["dendrites", "somata"]
    for l, name in zip([lines, planes], ["lines", "planes"]):
        if len(l) != 2:
            raise ValueError(f"2 {name} expected.")

    fig = ax[0, 0].figure

    if tight:
        # Calling tight layout here to ensure that labels are properly 
        # positioned with respect to final layout
        fig.tight_layout()

    # adds plane labels (vertical)
    plane_pos = plot_util.get_fig_rel_pos(ax, row_per_grp, dim="y")
    for plane, pos in zip(planes, plane_pos):
        fig.text(fig_xpos, pos, plane, rotation=90, fontsize="xx-large", 
            verticalalignment="center", weight="bold")

    # adds line names (horizontal)
    line_pos = plot_util.get_fig_rel_pos(ax, col_per_grp, dim="x")
    for c, (line, pos) in enumerate(zip(lines, line_pos)):
        if kind != "prog":
            ax[0, c].set_title(f"{line} Pyr", weight="bold") 
        else:
            # get ypos based on plane positions
            ypos = np.max(plane_pos) + np.absolute(np.diff(plane_pos)) * 0.5
            fig.text(pos, ypos, f"{line} Pyr", fontsize="xx-large", 
                horizontalalignment="center", weight="bold")

    # add axis labels
    add_linpla_axislabels(ax, fluor=fluor, area=area, datatype=datatype, 
        x_ax=xlab, y_ax=ylab, single_lab=single_lab, kind=kind)


#############################################
def plot_ROIs(sub_ax, masks, valid_mask=None, border=None, savename=None):
    """
    plot_ROIs(sub_ax, masks)

    Plots whole ROIs contours from a boolean mask, and optionally non valid
    ROIs in red.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    
    Optional args:
        - valid_mask (int): mask of valid ROIs (length of mask_bool). If None,
                            all ROIs plotted in white.
                            default: None
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - savename (bool) : if provided, saves mask contours to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - masks_plot_proj (2D array): ROI image array: hei x wid
    """

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)
    if valid_mask is None:
        valid_mask = np.ones(len(masks))

    color_list = ["black", "white", "red"]
    if valid_mask.all() and border is None:
        color_list = ["black", "white"]
    cm = mplcol.LinearSegmentedColormap.from_list(
        "roi_mask_cm", color_list, N=len(color_list))
    
    masks = masks.astype(bool).astype("int8")
    masks[~valid_mask.astype(bool)] *= 2
    masks_plot_proj = np.max(masks, axis=0)
    
    if border is not None:
        hei, wid = masks_plot_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]

        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        masks_plot_proj[hei_dash, right] = 2
        masks_plot_proj[hei_dash, wid-left] = 2
        masks_plot_proj[hei-down, wid_dash] = 2
        masks_plot_proj[up, wid_dash] = 2

    sub_ax.imshow(masks_plot_proj, cmap=cm, interpolation="none")

    if savename:
        plt.imsave(savename, masks_plot_proj, cmap=cm)

    return masks_plot_proj


#############################################
def plot_rec_proj(sub_ax, data, border=None, savename=None):
    """
    plot_rec_proj(sub_ax, data)

    Plots scaled average projection of recording data in black and white.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - data (3D array)          : recording data, structured as
                                     frames x hei x wid
    
    Optional args:
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - savename (bool) : if provided, saves masks to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - av_proj (2D array): data image array: hei x wid
    """

    if len(data.shape) == 2:
        data = np.expand_dims(data, 0)

    data_av = np.mean(data, axis=0)
    scale_min = np.min(data_av)
    scale_max = np.max(data_av)

    av_proj = (data_av - scale_min)/(scale_max - scale_min)

    color_list = ["black", "white", "red"]
    if border is None:
        color_list = ["black", "white"]
    cm = mplcol.LinearSegmentedColormap.from_list(
        "roi_mask_cm", color_list, N=100)
    
    if border is not None:
        hei, wid = av_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]
    
        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        av_proj[hei_dash, right] = 2
        av_proj[hei_dash, wid - left] = 2
        av_proj[hei - down, wid_dash] = 2
        av_proj[up, wid_dash] = 2

    sub_ax.imshow(av_proj, cmap=cm, interpolation="none")

    if savename:
        plt.imsave(savename, av_proj, cmap=cm)

    return av_proj


#############################################
def plot_ROIs_sep(sub_ax, masks, border=None, cm=None, savename=None):
    """
    plot_ROIs(sub_ax, masks)

    Plots whole ROIs contours from a boolean mask, and optionally non valid
    ROIs in red.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    
    Optional args:
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - cm (plt cm)     : pyplot colormap. If None, a custom cmap is used.
                            default: None
        - savename (bool) : if provided, saves masks to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - masks_max_proj (2D array): ROI image array: hei x wid
    """

    masks = masks.astype(bool).astype("int8")

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)

    # each ROI gets a number, and the number of the smallest ROI is retained in 
    # the projection
    n_pix = np.sum(masks, axis=(1, 2))
    roi_vals = np.argsort(n_pix)[::-1].reshape(-1, 1, 1) + 1
    masks_max_proj = np.max(masks * roi_vals, axis=0)

    n_rois = masks.shape[0]
    add_border = (border is not None)

    if cm is None:
        color_list = np.ones([n_rois + 1 + add_border, 4])
        color_list[0, :-1] = 0
        col_spacing = np.linspace(0, 1, n_rois)
        color_list[1 : 1 + n_rois] = mpl.cm.get_cmap("gist_rainbow")(col_spacing)
        cm = mplcol.LinearSegmentedColormap.from_list(
            "roi_mask_col_cm", color_list, N=len(color_list))
    
    # numbers remapped to original order
    remap = np.insert(np.argsort(roi_vals.reshape(-1)) + 1, 0, 0)
    masks_max_proj = remap[masks_max_proj]
    
    if border is not None:
        hei, wid = masks_max_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]
    
        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        masks_max_proj[hei_dash, right] = n_rois + 1
        masks_max_proj[hei_dash, wid - left] = n_rois + 1
        masks_max_proj[hei - down, wid_dash] = n_rois + 1
        masks_max_proj[up, wid_dash] = n_rois + 1

    sub_ax.imshow(masks_max_proj, cmap=cm, interpolation="none")

    if savename:
        plt.imsave(savename, masks_max_proj, cmap=cm)

    return masks_max_proj


#############################################
def plot_ROI_contours(sub_ax, masks, outlier=None, tight=False, 
                      restrict=False, cw=1, outer=False, cm=None, 
                      savename=False):
    """
    plot_ROI_contours(sub_ax, masks)

    Plots and returns ROI contours from a boolean mask, and optionally an 
    outlier in red. Optionally saves ROI contours to file.

    Required args:
        - sub_ax (plt Axis subplot): subplot (if None, masks are not plotted)
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    Optional args:
        - outlier (int)  : index of ROI, if any, for which to plot contour 
                           in a red.
                           default: None
        - tight (bool)   : if True, plot is restricted to the ROIs in the mask,
                           allowing for a 15% border, where possible
                           default: False
        - restrict (bool): if True, plot is restricted to the outlier ROI,
                           allowing for a 150% border, where possible. 
                           Overrides right.
                           default: True
        - cw (int)       : contour width (in pixels) (always within the ROI, 
                           unless outer)
                           default: 1
        - outer (bool)   : if True, the contours are drawn outside the ROI 
                           boundaries, instead of within
                           default: False
        - cm (plt cm)    : pyplot colormap. If None, a custom cmap is used.
                           default: None
        - savename (bool): if provided, saves mask contours to file 
                           (exact pixel size). ".png" best to avoid 
                           anti-aliasing.
                           default: False

    Returns:
        - contour_mask (2D array): ROI contour image array: hei x wid
    """

    if cm is None:
        color_list = ["black", "white", "red"]
        if outlier is None:
            color_list = ["black", "white"]
        cm = mplcol.LinearSegmentedColormap.from_list(
            "roi_mask_cm", color_list, N=len(color_list))

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)
    masks = np.ceil(masks).astype("int8")
    _, h_orig, w_orig = masks.shape

    if outlier is None and restrict:
        raise ValueError("'restrict' requires providing an outlier.")

    if tight or restrict:
        dims = h_orig, w_orig
        if restrict:
            border_p = 1.5
            dim_vals = np.where(masks[outlier])
            r_val = 1
        else:
            border_p = 0.15
            dim_vals = np.where(masks.sum(axis=0))
            r_val = 0
        dim_mins = [val.min() for val in dim_vals]
        dim_maxs = [val.max() for val in dim_vals]
        borders = [int(np.ceil(border_p * (dmax - dmin))) 
            for dmin, dmax in zip(dim_mins, dim_maxs)]
        h_min, w_min = [np.max([0, val - bord - r_val]) 
            for val, bord in zip(dim_mins, borders)]
        h_max, w_max = [np.min([d, val + bord + r_val]) 
            for val, bord, d in zip(dim_maxs, borders, dims)]
        masks = masks[:, h_min:h_max, w_min:w_max]

    pad_zhw = [0, 0], [cw, cw], [cw, cw]
    contour_mask = np.pad(masks, pad_zhw, "constant", constant_values=0)
    shifts = range(-cw, cw + 1)
    _, h, w = masks.shape
    for h_sh, w_sh in itertools.product(shifts, repeat=2):
        if h_sh == 0 and w_sh == 0:
            continue
        contour_mask[:, cw+h_sh: h+cw+h_sh, cw+w_sh: w+cw+w_sh] += masks
    
    sub_mask = contour_mask[:, cw:h+cw, cw:w+cw]
    contour_mask = (sub_mask != len(shifts) ** 2) * (sub_mask != 0)
    if outer:
        restrict_masks = 1 - masks
    else:
        restrict_masks = masks
    contour_mask = contour_mask * restrict_masks
    del masks

    if restrict:
        dim_vals = [h_min, h_max, w_min, w_max]
        comps = [0, h_orig, 0, w_orig]
        shifts = [0, 0, 0, 0]
        for i, (val, comp) in enumerate(zip(dim_vals, comps)):
            if val != comp:
                shifts[i] = r_val
        contour_mask = contour_mask[
            :, shifts[0]:comps[1] - shifts[1], shifts[2]:comps[3] - shifts[3]]
    
    mult_mask = np.ones([len(contour_mask), 1, 1])
    if outlier is not None:
        mult_mask[outlier] = 2
    contour_mask = np.max(contour_mask * mult_mask, axis=0)

    if sub_ax is not None:
        sub_ax.imshow(contour_mask, cmap=cm, interpolation="none")

    if savename:
        plt.imsave(savename, contour_mask, cmap=cm)

    return contour_mask

