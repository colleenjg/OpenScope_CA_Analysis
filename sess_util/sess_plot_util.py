"""
sess_plot_util.py

This module contains basic functions for plotting with pyplot data generated by 
the Allen Institute OpenScope experiments for the Credit Assignment Project.

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 3.7.

"""

import copy
from pathlib import Path

import itertools
import matplotlib as mpl
from matplotlib import colors as mplcol
from matplotlib import pyplot as plt
import numpy as np

from util import gen_util, math_util, plot_util
from sess_util import sess_str_util


#############################################
def init_figpar(ncols=4, sharex=False, sharey=True, subplot_hei=7, 
                subplot_wid=7, datetime=True, use_dt=None, fig_ext="svg", 
                overwrite=False, save_fig=True, runtype="prod", output=".", 
                plt_bkend=None, linclab=True, fontdir=None, paper=False):
    
    """
    Returns a dictionary containing figure parameter dictionaries for 
    initializing a figure, saving a figure, and extra save directory 
    parameters.

    Optional args: 
        - ncols (int)      : number of columns in the figure
                             default: 4 
        - sharex (bool)    : if True, x axis lims are shared across subplots
                             default: False 
        - sharey (bool)    : if True, y axis lims are shared across subplots
                             default: True
        - subplot_hei (num): height of each subplot (inches)
                             default: 7
        - subplot_wid (num): width of each subplot (inches)
                             default: 7
        - datetime (bool)  : if True, figures are saved in a subfolder named 
                             based on the date and time.
        - use_dt (Path)    : datetime folder to use
                             default: None
        - fig_ext (str)    : figure extension
                             default: "svg"
        - overwrite (bool) : if False, overwriting existing figures is 
                             prevented by adding suffix numbers.
                             default: False
        - save_fig (bool)  : if True, figures are saved
                             default: True
        - runtype (str)    : runtype ("pilot", "prod")
                             default: "prod"
        - output (Path)    : general directory in which to save output
                             default: "."
        - plt_bkend (str)  : mpl backend to use for plotting (e.g., "agg")
                             default: None
        - linclab (bool)   : linclab style setting 
                             default: None
        - fontdir (Path)   : path to directory where additional fonts are stored
                             default: None
        - paper (bool)     : if True, figures are paper figures, and default 
                             output folder is modified to paper_figures
                             default: False 
                             

    Returns:
        - figpar (dict): dictionary containing figure parameters:
            ["init"] : dictionary containing the following inputs as
                       attributes:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
            ["save"] : dictionary containing the following inputs as
                       attributes:
                           datetime, use_dt, fig_ext, overwrite, save_fig
            ["dirs"]: dictionary containing the following attributes:
                ["figdir"] (Path)   : main folder in which to save figures
                ["roi"] (Path)      : subdirectory name for ROI analyses
                ["run"] (Path)      : subdirectory name for running analyses
                ["acr_sess"] (Path) : subdirectory name for analyses across 
                                      sessions
                ["autocorr"] (Path) : subdirectory name for autocorrelation 
                                      analyses
                ["colormaps"] (Path): subdirectory name for colormap 
                                      analyses
                ["dir_idx"] (Path)  : subdirectory name for direction index 
                                      analyses
                ["full"] (Path)     : subdirectory name for full trace plots
                ["glm"] (Path)      : subdirectory name for glm plots
                ["grped"] (Path)    : subdirectory name for ROI grps data
                ["lat"] (Path)      : subdirectory name for latency analyses
                ["locori"] (Path)   : subdirectory name for location and 
                                      orientation responses
                ["mags"] (Path)     : subdirectory name for magnitude analyses
                ["loc_ori"] (Path)  : subdirectory name for location and 
                                      orientation plots
                ["prog"] (Path)     : subdirectory name for firsts progression 
                                      analysis                
                ["prop"] (Path)     : subdirectory name for proportion 
                                      responsive ROI analyses
                ["pupil"] (Path)    : subdirectory for pupil analyses
                ["oridir"] (Path)   : subdirectory name for 
                                      orientation/direction analyses
                ["unexp_qu"] (Path) : subdirectory name for unexpected, 
                                      quantile analyses
                ["unexp_idx"] (Path): subdirectory name for unexpected index 
                                      analyses
                ["tune_curv"] (Path): subdirectory name for tuning curves
                
            ["mng"]: dictionary containing the following attributes:
                ["plt_bkend"] (str): mpl backend to use
                ["linclab"] (bool) : if True, Linclab mpl defaults are used
                ["fontdir"] (Path) : path to directory containing additional 
                                     fonts
    """

    fig_init = {"ncols"      : ncols,
                "sharex"     : sharex,
                "sharey"     : sharey, 
                "subplot_hei": subplot_hei,
                "subplot_wid": subplot_wid,
                }

    use_dt = Path(use_dt) if use_dt is not None else use_dt
    fig_save = {"datetime" : datetime,
                "use_dt"   : use_dt,
                "fig_ext"  : fig_ext,
                "overwrite": overwrite,
                "save_fig" : save_fig,
                }
    
    fontdir = Path(fontdir) if fontdir is not None else fontdir
    fig_mng = {"linclab"  : linclab,
               "plt_bkend": plt_bkend,
               "fontdir"  : fontdir,
                }

    if paper:
        figdir = Path(output, "paper_figures")
    else:
        figdir = Path(output, "results", "figures")

    fig_dirs = {"figdir"   : figdir,
                "roi"      : Path(figdir, f"{runtype}_roi"),
                "run"      : Path(figdir, f"{runtype}_run"),
                "acr_sess" : "acr_sess",
                "autocorr" : "autocorr",
                "colormaps": "cms",
                "dir_idx"  : "dir_idx",
                "full"     : "full",
                "glm"      : "glm",
                "grped"    : "grped",
                "lat"      : "latencies",
                "mags"     : "mags",
                "loc_ori"  : "loc_ori",
                "prog"     : "prog",
                "prop"     : "prop_resp",
                "pupil"    : "pupil",
                "oridir"   : "oridir",
                "unexp_idx": "unexp_idx",
                "unexp_qu" : "unexp_qu",
                "tune_curv": "tune_curves",
               }
    fig_dirs = {key: Path(value) for key, value in fig_dirs.items()}

    figpar = {"init" : fig_init,
              "save" : fig_save,
              "dirs" : fig_dirs,
              "mng"  : fig_mng,
              }
    
    return figpar


#############################################
def get_quant_cols(n_quants=4):
    """
    get_quant_cols()

    Returns expected and unexpected colors for quantiles, as well as label 
    colors for expected and unexpected data.

    Required args:
        - n_quants (int): number of quantiles

    Returns:
        - cols (list)    : nested list of colors, 
                           structured as [expected, unexpected]
        - lab_cols (list): label colors for expected and unexpected data
    """

    col_exp   = plot_util.get_color_range(n_quants, "blue")
    col_unexp = plot_util.get_color_range(n_quants, "red")

    lab_exp   = plot_util.get_color_range(1, "blue")[0]
    lab_unexp = plot_util.get_color_range(1, "red")[0]

    cols = [col_exp, col_unexp]
    lab_cols = [lab_exp, lab_unexp]

    return cols, lab_cols


#############################################
def get_axislabels(fluor="dff", area=False, scale=False, datatype="roi", 
                   x_ax=None, y_ax=None):
    """
    get_axislabels()

    Returns appropriate labels for x and y axes. 
    
    If y_ax is None, y axis is assumed to be fluorescence, and label is 
    inferred from fluor and dff parameters. If x_ax is None, x axis is assumed
    to be time in seconds.

    Optional args:
        - fluor (str)     : if y_ax is None, whether "raw" or processed 
                            fluorescence traces "dff" are plotted. 
                            default: "dff"
        - area (bool)     : if True, "area" is added after the y_ax label
                            default: False
        - scale (bool)    : if True, "(scaled)" is added after the y_ax label
                            default: False
        - datatype (str)  : type of data, either "run" or "roi"
                            default: "roi"
        - x_ax (str)      : label to use for x axis.
                            default: None
        - y_ax (str)      : label to use for y axis.
                            default: None

    Returns:
        - x_str (str): X axis label
        - y_str (str): Y axis label
    """

    area_str = ""
    if area:
        area_str = " area"
    
    scale_str = ""
    if scale:
        scale_str = " (scaled)"

    if x_ax is None:
        x_str = "Time (s)"
    else:
        x_str = x_ax

    if y_ax is None:
        if datatype == "roi":
            y_str = sess_str_util.fluor_par_str(fluor, str_type="print")
        elif datatype == "run":
            y_str = "Running velocity (cm/s)"
        else:
            gen_util.accepted_values_error("datatype", datatype, ["roi", "run"])
    else:
        y_str = y_ax

    y_str = u"{}{}{}".format(y_str, area_str, scale_str)

    return x_str, y_str


#############################################
def add_axislabels(sub_ax, fluor="dff", area=False, scale=False, datatype="roi", 
                   x_ax=None, y_ax=None, first_col=True, last_row=True):
    """
    add_axislabels(sub_ax)

    Adds the appropriate labels to the subplot x and y axes. 
    (See get_axislabel())
    
    Required args:
        - sub_ax (plt Axis subplot): subplot

    Optional args:
        - fluor (str)     : if y_ax is None, whether "raw" or processed 
                            fluorescence traces "dff" are plotted. 
                            default: "dff"
        - area (bool)     : if True, "area" is added after the y_ax label
                            default: False
        - scale (bool)    : if True, "(scaled)" is added after the y_ax label
                            default: False
        - datatype (str)  : type of data, either "run" or "roi"
                            default: "roi"
        - x_ax (str)      : label to use for x axis.
                            default: None
        - y_ax (str)      : label to use for y axis.
                            default: None
        - first_col (bool): if True, only add an y axis label to subplots in 
                            first column
                            default: True
        - last_row (bool) : if True, only add an x axis label to subplots in 
                            last row
                            default: True
    """

    x_str, y_str = get_axislabels(fluor, area, scale, datatype, x_ax, y_ax)

    if not(last_row) or plot_util.is_last_row(sub_ax):
        sub_ax.set_xlabel(x_str)

    if not(first_col) or plot_util.is_first_col(sub_ax):
        sub_ax.set_ylabel(y_str)


#############################################
def get_fr_lab(plot_vals="both", op="diff", start_fr=0):
    """
    get_fr_lab()

    Returns a list of labels for gabor frames based on values that are plotted,
    and operation on unexpected v expected, ending with grayscreen (G).

    Optional args:
        - plot_vals (str): values plotted ("unexp", "exp", "both")
                           default: "both"
        - op (str)       : operation on the values, if both ("ratio" or "diff")
                           default: "diff"
        - start_fr (int) : starting gabor frame 
                           (0: A, 1: B, 2:C, 3:D/U, 4: G)
                           default: -1
    
    Returns:
        - labels (list)  : list of labels for gabor frames
    """

    labels = ["A", "B", "C"]

    if plot_vals == "unexp":
        labels.extend(["U"])
    elif plot_vals == "exp":
        labels.extend(["D"])
    elif plot_vals == "both":
        if op == "diff":
            labels.extend(["U-D"])      
        elif op == "ratio":
            labels.extend(["U/D"])
        else:
            gen_util.accepted_values_error("op", op, ["diff", "ratio"])
    else:
        gen_util.accepted_values_error(
            "plot_vals", plot_vals, ["both", "exp", "unexp"])

    labels.append("G")

    if start_fr != 0:
        labels = list(np.roll(labels, -start_fr))

    return labels


#############################################
def get_seg_comp(gabfr=0, plot_vals="both", op="diff", pre=0, post=1.5):
    """
    get_seg_comp()

    Returns lists with different components needed when plotting segments, 
    namely positions of labels, ordered labels, positions of heavy bars and 
    position of regular bars.

    Optional args:
        - gabfr (int)    : gabor frame of reference
                           default: 0
        - plot_vals (str): values plotted ("unexp", "exp", "both")
                           default: "both"
        - op (str)       : operation on the values, if both ("ratio" or "diff")
                           default: "diff"
        - pre (num)      : range of frames to include before reference frame 
                           (in s)
                           default: 0 (only value implemented)
        - post (num)     : range of frames to include after reference frame
                           (in s)
                           default: 1.5 (only value implemented)
    
    Returns:
        - xpos (list)          : list of x coordinates at which to add labels
                                 (same length as labels)
        - labels (list)         : ordered list of labels for gabor frames
        - hbars (list or float): list of x coordinates at which to add 
                                 heavy dashed vertical bars
        - bars (list or float) : list of x coordinates at which to add 
                                 dashed vertical bars
    """

    if gabfr not in list(range(0, 4)):
        raise ValueError("Gabor frame must be 0, 1, 2 or 3.")

    seg_len = 0.3

    pre_segs = int(np.floor(pre/seg_len)) # number of segs pre
    n_segs = int(np.floor((pre + post)/seg_len)) # number of segs
    xpos = [(x + 0.5 - pre_segs) * seg_len for x in range(n_segs)]
    bars = [(x - pre_segs) * seg_len for x in range(n_segs)]
    
    labels = get_fr_lab(plot_vals, op, gabfr - pre_segs)
    if len(labels) < len(xpos):
        labels = labels * (len(xpos)//len(labels) + 1)
    if len(labels) > len(xpos):
        labels = labels[:len(xpos)]

    hbars = [bars[x] for x in range(1, len(bars)) if labels[x-1] in ["C", "G"]]
    bars = gen_util.remove_if(bars, [-pre] + hbars)
    hbars = gen_util.remove_if(hbars, -pre)

    return xpos, labels, hbars, bars


#############################################
def plot_labels(ax, gabfr=0, plot_vals="both", op="none", pre=0, post=1.5, 
                cols=None, sharey=True, t_heis=[0.85, 0.75], incr=True, 
                omit_empty=True, **axline_kw):
    """
    plot_labels(ax)

    Plots lines and labels for gabors segments.
   
    Required args:
        - ax (plt Axis): axis

    Optional args:
        - gabfr (int)      : gabor frame of reference
                             default: 0
        - plot_vals (str)  : values plotted ("unexp", "exp", "both")
                             default: "both"
        - op (str)         : operation on the values, if both 
                             ("ratio" or "diff")
                             default: "none"
        - pre (num)        : range of frames to include before reference frame 
                             (in s)
                             default: 0 (only value implemented)
        - post (num)       : range of frames to include after reference frame
                             (in s)
                             default: 1.5 (only value implemented)
        - cols (str)       : colors to use for labels
                             default: None
        - sharey (bool)    : if True, y axes are shared
                             default: True
        - t_heis (list)    : height(s) at which to place labels. If t_hei 
                             includes negative values, the ylims are not 
                             modified.
                             default: [0.85, 0.75]
        - incr (bool)      : if True, y axis limits are increased to accomodate
                             labels
                             default: True
        - omit_empty (bool): if True, no labels are added to subplots with no 
                             lines plotted
                             default: True 

    Keyword args:
        - axline_kw (dict): keyword arguments for plot_util.add_bars 
                            (-> plt.axvline() or plt.axhline())
    """

    t_heis = gen_util.list_if_not(t_heis)
    if cols is None:
        cols = ["k", "k"]

    min_t_hei = min(t_heis)
    if min_t_hei > 0:
        plot_util.incr_ymax(ax, incr=1.05/min_t_hei, sharey=sharey)

    if plot_vals == "both":
        if op == "none":
            plot_vals = ["exp", "unexp"]

    plot_vals = gen_util.list_if_not(plot_vals)

    n_ax = np.product(ax.shape)
    for i in range(n_ax):
        sub_ax = plot_util.get_subax(ax, i)
        if omit_empty and len(sub_ax.lines) == 0:
            continue
        for i, pv in enumerate(plot_vals):
            [xpos, lab, h_bars, seg_bars] = get_seg_comp(
                gabfr, pv, op, pre, post)
            plot_util.add_labels(sub_ax, lab, xpos, t_heis[i], cols[i])
        plot_util.add_bars(sub_ax, hbars=h_bars, bars=seg_bars, **axline_kw)


#############################################
def plot_gabfr_pattern(sub_ax, x_ran, alpha=0.1, offset=0, bars_omit=[], 
                       shade_col="k", shade_lim="all"):
    """
    plot_gabfr_pattern(sub_ax, x_ran)

    Plots light dashed lines at the edges of each gabor sequence (end of 
    grayscreen (G)) and shades D/U segments.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - x_ran (array-like)       : range of x axis values 
                                     (or at least [min, max])

    Optional args:
        - alpha (num)     : plt alpha variable controlling shading 
                            transparency (from 0 to 1)
                            default: 0.1
        - offset (num)    : offset of sequence start from 0 in segs 
                            (start gabor frame number)
                            default: 0
        - bars_omit (list): positions at which to omit bars (e.g., in case they 
                            would be redundant)
                            default: []
        - shade_col (str) : D/U shading colour (none, if "none")
                            default: "k"
        - shade_lim (str) : how to limit shading 
                            "all": no limits within x_ran
                            "neg": only within x_ran =< 0
                            "pos": only within x_ran >= 0
                            default: "all"
    """

    offset_s = np.round(0.3 * offset, 10) # avoid periodic values

    x_min, x_max = [np.min(x_ran), np.max(x_ran)]
    bars = plot_util.get_repeated_bars(x_min, x_max, 1.5, 
        offset=-offset_s) # sequence start/end
    bars = gen_util.remove_if(bars, bars_omit + [x_min, x_max])
    plot_util.add_bars(sub_ax, bars=bars)

    sh_min, sh_max = x_min, x_max
    if shade_lim == "pos":
        sh_min = np.max([sh_min, 0])
    elif shade_lim == "neg":
        sh_max = np.min([sh_max, 0])
    elif shade_lim != "all":
        gen_util.accepted_values_error(
            "shade_lim", shade_lim, ["all", "pos", "neg"])

    shade_wid = 0.3
    # get the extended shade starts
    ext_shade_st = plot_util.get_repeated_bars(
        sh_min - shade_wid, sh_max + shade_wid, 1.5, 
        offset=-offset_s - 0.6) # unexpected seq start

    shade_st = []
    shade_end = []
    for st in ext_shade_st:
        end = st + shade_wid
        if st < sh_min:
            st = sh_min
        if end > sh_max:
            end = sh_max
        if end > st:
            shade_st.append(st)
            shade_end.append(end)

    if len(shade_st) != 0 and shade_col not in ["None", "none"]:
        plot_util.add_vshade(
            sub_ax, shade_st, shade_end, alpha=alpha, color=shade_col)


#############################################
def get_gab_time_xticks(xran, lock=False, step=0.15):
    """
    get_gab_time_xticks(xran)

    Returns xtick values for Gabor response traces.

    Required args:
        - xran (array-like): x-values for the data, or at least the [min, max]

    Optional args:
        - lock (bool): if True, xran is replicated in the negative
                       default: False
        - step (num) : step size
                       default: 0.15
    
    Returns:
        - xticks (list): x tick values
    """

    max_tick = int(np.ceil(np.max(xran) / step)) * step
    if lock:
        min_tick = - max_tick
        if min_tick > max_tick:
            raise ValueError("If 'lock' is True, 'xran' should be positive.")
    else:
        min_tick = int(np.min(xran) / step) * step
    if max_tick - min_tick == 0:
        n_ticks = 1
    else:
        n_ticks = int((max_tick - min_tick)/step)
        n_tick_vals = math_util.get_divisors(n_ticks, min_val=2, max_val=5)
        n_ticks = 6 if len(n_tick_vals) == 0 else n_tick_vals[-1] + 1
    xticks = np.linspace(min_tick, max_tick, n_ticks)

    if len(xticks) > 1:
        diff = np.min(np.diff(xticks))
        n_dig = - np.floor(np.log10(np.absolute(diff))).astype(int) + 1
        xticks = [np.around(v, n_dig) for v in xticks]

    return xticks


#############################################
def update_plt_linpla(transparent=True):
    """
    update_plt_linpla()

    Updates rcParams for plane x line plots.

    Optional args:
        - transparent (bool): figure save parameter
                              default: True
    """

    plt.rcParams.update({
        "lines.linewidth"      : 5.0, 
        "patch.linewidth"      : 5.0, 
        "axes.labelsize"       : "x-large",
        "axes.linewidth"       : 4.0, 
        "axes.titlesize"       : "x-large",
        "figure.titlesize"     : "x-large",
        "xtick.major.width"    : 4.0, 
        "ytick.major.width"    : 4.0, 
        "lines.markeredgewidth": 4.0, 
        "legend.fontsize"      : "large",
        })
        
    return


#############################################
def fig_init_linpla(figpar=None, kind="reg", n_sub=1, sharey=False, 
                    sharex=True):
    """
    fig_init_linpla()

    Returns figpar dictionary with initialization parameters modified for
    graphs across sessions divided by line/plane combinations.

    Optional args:
        - figpar (dict)       : dictionary containing figure parameters 
                                (initialized if None):
            ["init"] : dictionary containing the following inputs as
                       attributes:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
                                default: None
        - kind (str)          : kind of plot 
                                "reg" for single plot per layer/line, 
                                "traces" for traces plot per session (rows),
                                "traces_double" for traces plot with 2 plots 
                                    per row, 
                                "prog" for progression plot per session (cols), 
                                "idx" for unexpected data index plot per 
                                    session (rows)
                                default: "reg"
        - n_sub (int)         : number of subplots per line/plane combination
                                default: 1
        - sharey (bool)       : y-axis sharing parameter
                                default: False
        - sharex (bool)       : x-axis sharing parameter
                                default: True

    Returns:
        - figpar (dict): dictionary containing figure parameters:
            ["init"] : dictionary containing the following inputs modified:
                           ncols, sharex, sharey, subplot_hei, subplot_wid
    """

    figpar = copy.deepcopy(figpar)

    if figpar is None:
        figpar = init_figpar()

    if "init" not in figpar.keys():
        raise KeyError("figpar should have 'init' subdictionary.")

    if sharey in [False, "rows"]:
        wspace = 0.5
    else:
        wspace = 0.2

    ncols = 2
    if kind == "traces":
        wid = 3.3
        hei = np.max([wid/n_sub * 1.15, 1.0])
    if kind == "traces_double":
        ncols *= 2
        wid = 3.3
        hei = np.max([wid/n_sub * 1.15, 1.0])
    elif kind == "prog":
        ncols *= n_sub
        wid = np.max([9.0/n_sub, 3.0])
        hei = 2.3
    elif kind == "idx":
        wid = 5
        hei = np.max([wid * 1.5/n_sub, 1.0])
    else:
        wid = 2.5
        hei = 4.3
        figpar["init"]["gs"] = {"hspace": 0.15, "wspace": wspace}

    figpar["init"]["ncols"] = ncols
    figpar["init"]["subplot_hei"] = hei
    figpar["init"]["subplot_wid"] = wid
    figpar["init"]["sharex"] = sharex
    figpar["init"]["sharey"] = sharey

    return figpar


#############################################
def fig_linpla_pars(n_sess=False, n_grps=None):
    """
    fig_linpla_pars()

    Returns parameters for a line/plane combination graph.

    Optional args:
        - n_sess (bool or int): if not False, provides number of sessions 
                                plotted separately per line/plane combination 
                                and used in multiplying number of plots
                                default: False
        - n_grps (int or None): if not None, the number of groups in the data 
                                is verified against the expected number of 
                                groups
                                default: None

    Returns:
        - lines (list)        : ordered list of lines
        - planes (list)       : ordered list of planes
        - linpla_iter (list)  : ordered list of lines and planes, structured as 
                                grp x [lin, pla]
        - pla_cols (list)     : colors for each plane
        - pla_col_names (list): color names for each plane
        - n_plots (int)       : total number of plots
    """

    lines, planes = ["L2/3", "L5"], ["dendrites", "somata"]
    linpla_iter = [[lin, pla] for lin in lines for pla in planes]
    pla_col_names = ["green", "blue"]
    pla_cols = [plot_util.get_color(c, ret="single") for c in pla_col_names]
    
    if n_sess:
        mult = n_sess
    else:
        mult = 1
    n_plots = len(lines) * len(planes) * mult

    if n_grps is not None and n_grps > n_plots/mult:
        raise ValueError(f"Expected up to {n_plots} line x plane "
            f"combinations, not {n_grps}.")

    return lines, planes, linpla_iter, pla_cols, pla_col_names, n_plots


#############################################
def adjust_linpla_y_axis_sharing(ax, kind="reg", doublets=True):
    """
    adjust_linpla_y_axis_sharing(ax)

    If no y axes are shared, sets y-axes belonging to the same plane/line group 
    to be shared, and updates axis scaling.

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - kind (str)     : kind of plot 
                           "reg" for single plot per layer/line, 
                           "traces" for traces plot per session (rows), 
                           "traces_double" for traces plot with 2 plots 
                              per row, 
                           "prog" for progression plot per session (cols), 
                           "idx" for unexpected data index plot per 
                              session (rows)
                           default: "reg"
        - doublets (bool): if kind is 'traces_double', axes are only shared 
                           within doublets, not quadrants
    """

    # check whether any y axes are shared
    set_sharey = (len(plot_util.get_shared_axes(ax, axis="y")) == 0)

    if kind in ["reg", "map"] or not set_sharey:
        return

    n_rows, n_cols = ax.shape
    to_share = []
    if kind in ["traces", "idx"]:
        n_cols = 2
        if n_rows % 2 != 0:
            raise RuntimeError("Expected even number of rows")
        row_per_grp = int(n_rows/2)
        num_row_grps = int(n_rows/row_per_grp)
        if row_per_grp > 1:
            to_share = [[ax[row_grp * row_per_grp + r, c] 
                for r in range(row_per_grp)] 
                for row_grp in range(num_row_grps) for c in range(n_cols)]
    elif kind == "prog":
        n_rows = 2
        if n_cols % 2 != 0:
            raise RuntimeError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
        num_col_grps = int(n_cols/col_per_grp)
        if col_per_grp > 1:
            to_share = [[ax[r, col_grp * col_per_grp + c] 
                for c in range(col_per_grp)] 
                for col_grp in range(num_col_grps) for r in range(n_rows)]
    elif kind == "traces_double":
        if n_rows % 2 != 0 or n_cols != 4:
            raise RuntimeError("Expected even number of rows and 4 columns.")
        if doublets:
            row_per_grp = 1
        else:
            row_per_grp = int(n_rows/2)
        col_per_grp = int(n_cols/2)
        num_row_grps = int(n_rows/row_per_grp)
        num_col_grps = int(n_cols/col_per_grp)
        if row_per_grp > 1 or col_per_grp > 1:
            to_share = [
                [ax[row_grp * row_per_grp + r, col_grp * col_per_grp + c] 
                for r in range(row_per_grp) for c in range(col_per_grp)] 
                for row_grp in range(num_row_grps) 
                for col_grp in range(num_col_grps)
                ]

    else:
        gen_util.accepted_values_error(
            "kind", kind, [
                "reg", "traces", "traces_double", "prog", "idx", "map"]
                )

    for axis_set in to_share:
        plot_util.set_shared_axes(axis_set, "y")
        if kind in ["traces", "idx"]:
            remove_labs = axis_set[:-1]
        elif kind in "prog":
            remove_labs = axis_set[1:]
        elif kind == "traces_double":
            if doublets:
                remove_labs = axis_set[1:]
            else:
                remove_labs = axis_set[:-2] + axis_set[-1:] # all but next to last
        for subax in remove_labs:
            subax.tick_params(axis="y", labelleft=False)

    for sub_ax in ax.reshape(-1):
       sub_ax.autoscale()

    return


#############################################
def get_yticklabel_info(ax, kind="reg"):
    """
    get_yticklabel_info(ax)

    Returns information on how to label y axes.

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - kind (str): kind of plot 
                      "reg" for single plot per layer/line, 
                      "traces" for traces plot per session (rows), 
                      "traces_double" for traces plot with 2 plots 
                          per row, 
                      "prog" for progression plot per session (cols), 
                      "idx" for unexpected data index plot per 
                           session (rows)
                      "map" for ROI maps

    Returns:
        - add_yticks (list) : list of subplots that should have ytick labels
    """

    if kind == "map":
        return []

    # establish which subplots should have y tick labels
    axgrps = plot_util.get_shared_axes(ax, axis="y")
    if len(axgrps) == 4: # sharing by group
        add_idx = -1
        if kind == "prog":
            add_idx = 0
        add_yticks = [axg[add_idx] for axg in axgrps]

    elif len(axgrps) == 0: # no sharing
        add_yticks = ax.reshape(-1)
    elif len(axgrps) == 1: # all sharing
        add_yticks = ax[-1, 0:]
    elif len(axgrps) == ax.shape[0]: # sharing by row
        add_yticks = ax[:, 0].reshape(-1)
    elif len(axgrps) == ax.shape[0] * ax.shape[1] // 2: # sharing by doublets
        add_yticks = [axg[0] for axg in axgrps]
    else:
        raise NotImplementedError(f"Condition for {len(axgrps)} subplots in "
            "shared axis groups not implemented.")

    return add_yticks


#############################################
def add_linpla_axislabels(ax, fluor="dff", area=False, scale=False, 
                          datatype="roi", x_ax=None, y_ax=None, 
                          single_lab=False, kind="reg"):
    """
    add_linpla_axislabels(ax)

    Adds the appropriate axis labels to the figure axes. 
    (See get_axislabel() for label content)

    Required args:
        - ax (plt Axis): ax

    Optional args:
        - fluor (str)      : if y_ax is None, whether "raw" or processed 
                             fluorescence traces "dff" are plotted. 
                             default: "dff"
        - area (bool)      : if True, "area" is added after the y_ax label
                             default: False
        - scale (bool)     : if True, "(scaled)" is added after the y_ax label
                             default: False
        - datatype (str)   : type of data, either "run" or "roi"
                             default: "roi"
        - x_ax (str)       : label to use for x axis.
                             default: None
        - y_ax (str)       : label to use for y axis.
                             default: None
        - single_lab (bool): if True, y label only added to top, left of each 
                             subplot group sharing y axis, and x label only 
                             added to bottom, middle, and tick labels only 
                             added to bottom left
                             default: False
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows),  
                             "traces_double" for traces plot with 2 plots 
                                 per row, 
                             "prog" for progression plot per session (cols), 
                             "idx" for unexpected data index plot per 
                                session (rows)
                             "map" for ROI maps
    """

    if kind == "map":
        return

    add_yticks = get_yticklabel_info(ax, kind=kind)

    # get axis labels if not already provided
    x_str, y_str = get_axislabels(fluor, area, scale, datatype, x_ax, y_ax)

    fig = ax.reshape(-1)[0].figure
    n_rows, n_cols = ax.shape
    if n_rows % 2 != 0 or n_cols % 2 != 0:
        raise RuntimeError("Expected even number of rows and columns.")
    row_per_grp = int(n_rows / 2)
    col_per_grp = int(n_cols / 2)
    
    # add x label
    if single_lab:    
        if kind == "reg":
            fig_ypos = 0.03
        elif kind in ["traces", "idx"]:
            fig_ypos = -0.01
        elif kind == "traces_double":
            fig_ypos = -0.01
        else:
            fig_ypos = -0.02
        fig.text(0.5, fig_ypos, x_str, fontsize="x-large", 
            horizontalalignment="center", weight="bold")
    else:
        for sub_ax in ax.reshape(-1):
            if plot_util.is_last_row(sub_ax):
                if kind in ["traces_double", "prog"]:
                    x_pos = fig.transFigure.inverted().transform(
                        sub_ax.transAxes.transform([0.5, 0]))[0]
                    fig.text(x_pos, 0, x_str, fontsize="x-large", 
                        horizontalalignment="center", weight="bold")
                else:
                    sub_ax.set_xlabel(x_str, weight="bold")

    # y labels for each plane set (top and bottom)
    add_y_pos = plot_util.get_fig_rel_pos(ax, row_per_grp, axis="y")
    if single_lab:
        add_y_pos = add_y_pos[:1] # top only

    ax[0, 0].set_ylabel(".", labelpad=5, color="white") # dummy label
    fig.canvas.draw() # must draw to get axis extent
    fig_transform = fig.transFigure.inverted().transform
    y_lab_xpos = fig_transform(ax[0, 0].yaxis.label.get_window_extent())[0, 0]
    
    for y_pos in add_y_pos:
        fig.text(y_lab_xpos, y_pos, y_str, rotation=90, fontsize="x-large", 
            verticalalignment="center", weight="bold")

    # remove tick labels for all but last row and first column
    label_cols = [0]
    skip_x = False
    if kind in ["traces_double", "prog"]:
        label_cols = [0, col_per_grp]
    elif kind == "idx":
        skip_x = True
        if len(plot_util.get_shared_axes(ax, axis="x")) != 1:
            skip_x = False
    if single_lab:
        for sub_ax in ax.reshape(-1):
            colNum = sub_ax.get_subplotspec().colspan.start
            if (not (plot_util.is_last_row(sub_ax) and colNum in label_cols) and 
                skip_x):
                sub_ax.tick_params(labelbottom=False)
            if sub_ax not in add_yticks:
                sub_ax.tick_params(labelleft=False)


#############################################
def format_each_linpla_subaxis(ax, xticks=None, sess_ns=None, kind="reg", 
                               single_lab=True, sess_text=True):
    """
    format_each_linpla_subaxis(ax)

    Formats each subaxis separately, specifically:
    
    - Adds session numbers if provided
    - Removes bottom lines and ticks for top plots
    - Adds x tick labels to bottom plots
    - Adds y tick labels to correct plots

    Required args:
        - ax (plt Axis): plt axis

    Optional args:
        - xticks (list)    : x tick labels (if None, none are added)
                             default: None
        - sess_ns (list)   : list of session numbers
                             default: None 
        - kind (str)       : kind of plot 
                             "reg" for single plot per layer/line, 
                             "traces" for traces plot per session (rows), 
                             "traces_double" for traces plot with 2 plots 
                                 per row, 
                             "prog" for progression plot per session (cols), 
                             "idx" for unexpected data index plot per 
                                session (rows)
                             default: "reg"
        - single_lab (bool): if True, only one set of session labels it added 
                             to the graph
                             default: True 
        - sess_text (bool) : if True, session numbers are included as text in 
                             the subplots
                             default: True
    """
    # make sure to autoscale subplots after this, otherwise bugs emerge
    for sub_ax in ax.reshape(-1):
        sub_ax.autoscale()

    # get information based on kind of graph
    n_rows, n_cols = ax.shape
    col_per_grp = 1
    pad_p = 0
    if kind == "reg":
        if xticks is not None:
            div = len(xticks)
            pad_p = 1.0 / div
        if n_rows != 2 or n_cols != 2:
            raise RuntimeError(
                "Regular plots should have 2 rows and 2 columns."
                )
    elif kind in ["traces_double", "prog"]:
        if n_cols % 2 != 0:
            raise RuntimeError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
    
    elif kind == "map":
        for sub_ax in ax.reshape(-1):
            plot_util.remove_axis_marks(sub_ax)
            for spine in ["right", "left", "top", "bottom"]:
                sub_ax.spines[spine].set_visible(True)
                
    elif kind not in ["traces", "idx"]:
        gen_util.accepted_values_error(
            "kind", kind, ["reg", "traces", "prog", "idx", "map"]
            )

    if kind == "map":
        return

    for r in range(n_rows):
        for c in range(n_cols):
            sub_ax = ax[r, c]
            # set x ticks
            if xticks is not None:
                plot_util.set_ticks(sub_ax, axis="x", min_tick=min(xticks), 
                    max_tick=max(xticks), n=len(xticks), pad_p=pad_p)
                # always set ticks (even again) before setting labels
                sub_ax.set_xticklabels(xticks, weight="bold")
                # to avoid very wide plot features
                if len(xticks) == 1:
                    sub_ax.set_xlim(xticks[0] - 1, xticks[0] + 1)
            # add session numbers
            if kind in ["traces", "traces_double", "idx", "prog"] and sess_ns is not None:
                if sess_text:
                    # place session labels in right/top subplots
                    if kind == "prog":
                        sess_idx = c % len(sess_ns)
                        if r != 0 or c < len(sess_ns):
                            sess_idx = None
                    else:
                        sess_idx = r
                        targ_col = 3 if kind == "traces_double" else 1
                        if c != targ_col or r >= len(sess_ns):
                            sess_idx = None
                    if sess_idx is not None:
                        sess_lab = f"sess {sess_ns[sess_idx]}"
                        sub_ax.text(0.65, 0.75, sess_lab, fontsize="x-large", 
                            transform=sub_ax.transAxes, style="italic")
                elif kind == "prog": # alternative session labels for "prog"
                    if (plot_util.is_last_row(sub_ax) and 
                        (c < len(sess_ns) or not(single_lab))): # BOTTOM
                        sub_ax.text(0.5, -0.5, sess_ns[c % len(sess_ns)], 
                            fontsize="x-large", transform=sub_ax.transAxes, 
                            weight="bold")
            
            # remove x ticks and spines from graphs
            if not plot_util.is_last_row(sub_ax) and kind != "idx": # NOT BOTTOM
                sub_ax.tick_params(axis="x", which="both", bottom=False) 
                sub_ax.spines["bottom"].set_visible(False)

            # remove y ticks and spines from graphs
            colNum = sub_ax.get_subplotspec().colspan.start
            if kind in ["prog", "traces_double"] and not colNum in [0, col_per_grp]:
                sub_ax.tick_params(axis="y", which="both", left=False) 
                sub_ax.spines["left"].set_visible(False)

            yticks = [np.around(v, 10) for v in sub_ax.get_yticks()]
            if kind in ["traces", "traces_double", "idx"] and len(yticks) > 3:
                max_abs = np.max(np.absolute(yticks))
                new = [-max_abs, 0, max_abs]
                yticks = list(filter(lambda x: x == 0 or x in yticks, new))

            # always set ticks (even again) before setting labels
            sub_ax.set_yticks(yticks)
            sub_ax.set_yticklabels(yticks, weight="bold")            



#############################################
def format_linpla_subaxes(ax, fluor="dff", area=False, datatype="roi", 
                          lines=None, planes=None, xlab=None, xticks=None, 
                          sess_ns=None, ylab=None, kind="reg", tight=True, 
                          modif_share=True, single_lab=True):
    """
    format_linpla_subaxes(ax)

    Formats axis labels and grids for a square of subplots, structured as 
    planes (2 or more rows) x lines (2 columns). 
    
    Specifically:
    - Adds line names to top plots
    - Adds plane information on right plots (midde of top and bottom half)

    Calls:
        - adjust_linpla_y_axis_sharing()
        - format_each_linpla_subaxis()
        - add_linpla_axislabels()

    Required args:
        - ax (plt Axis): plt axis

    Optional args:
        - fluor (str)       : if ylab is None, whether "raw" or processed 
                              fluorescence traces "dff" are plotted. 
                              default: "dff"
        - area (bool)       : if True, "area" is added after the ylab label
                              default: False
        - datatype (str)    : type of data, either "run" or "roi"
                              default: "roi"
        - lines (list)      : ordered lines (2)
                              default: None
        - planes (list)     : ordered planes (2)
                              default: None
        - xlab (str)        : x label
                              default: None
        - xticks (list)     : x tick labels (if None, none are added)
                              default: None
        - sess_ns (list)    : list of session numbers
                              default: None 
        - ylab (str)        : y axis label (overrides automatic one)
                              default: None
        - kind (str)        : kind of plot 
                              "reg" for single plot per layer/line, 
                              "traces_double" for traces plot with 2 plots 
                                  per row, 
                              "traces" for traces plot per session (rows), 
                              "prog" for progression plot per session (cols), 
                              "idx" for unexpected data index plot per 
                                  session (rows)
                              default: "reg"
        - tight (bool)      : tight figure layout
                              default: True
        - modif_share (bool): if True, y axis sharing modifications are not made
                              default: True
        - single_lab (bool) : if True, where possible, duplicate labels 
                              (axes and ticks) are omitted.
                              default: True
    """
    
    if kind != "idx" and modif_share:
        adjust_linpla_y_axis_sharing(ax, kind=kind)

    sess_text = False if (kind == "prog" and xlab is None) else True
    format_each_linpla_subaxis(
        ax, xticks=xticks, sess_ns=sess_ns, kind=kind, sess_text=sess_text
        )

    # get information based on kind of graph
    n_rows, n_cols = ax.shape
    row_per_grp, col_per_grp = 1, 1
    if kind in ["reg", "map"]:
        fig_xpos = 0.93 # for plane names (x pos)
        fig_ypos = 1 if kind == "reg" else 1.02 # for line names (y pos)
        n = 4
        if n_rows != 2 or n_cols != 2:
            raise RuntimeError(
                "Regular or map plots should have 2 rows and 2 columns."
                )
    elif kind in ["traces", "idx"]:
        fig_xpos = 1.0 # for plane names (x pos)
        fig_ypos = 1.04 # for line names (y pos)
        if n_rows % 2 != 0:
            raise RuntimeError("Expected even number of rows")
        row_per_grp = int(n_rows/2)
        col_per_grp = int(n_cols/2)
        n = 4
    elif kind == "prog":
        n = 3
        fig_xpos = 1.0 # for plane names (x pos)
        fig_ypos = 1.02 # for line names (y pos)
        if n_cols % 2 != 0:
            raise RuntimeError("Expected even number of columns")
        col_per_grp = int(n_cols/2)
    elif kind == "traces_double":
        n = 3
        fig_xpos = 1.0 # for plane names (x pos)
        fig_ypos = 1.04 # for line names (y pos)
        if n_rows % 2 != 0:
            raise RuntimeError("Expected an even number of rows")
        if n_cols != 4:
            raise RuntimeError("Expected 4 columns")
        row_per_grp = int(n_rows/2)
        col_per_grp = int(n_cols/2)
    else:
        gen_util.accepted_values_error(
            "kind", kind, ["reg", "traces", "traces_double", "prog", "idx"])

    if kind in ["reg", "prog", "idx"]:
        plot_util.set_interm_ticks(ax, n, axis="y", weight="bold", share=False)

    # get x axis label and tick information
    if kind in ["traces", "traces_double"]:
        xlab = "Time (s)" if xlab is None else xlab
    elif kind == "idx":
        xlab = "Index" if xlab is None else xlab
    elif kind != "map":
        xlab = "Session" if xlab is None else xlab

    # get and check lines and planes
    if lines is None:
        lines = ["L2/3", "L5"]
    if planes is None:
        planes = ["dendrites", "somata"]
    for l, name in zip([lines, planes], ["lines", "planes"]):
        if len(l) != 2:
            raise RuntimeError(f"2 {name} expected.")

    fig = ax[0, 0].figure

    if tight:
        # Calling tight layout here to ensure that labels are properly 
        # positioned with respect to final layout
        fig.tight_layout()

    # adds plane labels (vertical)
    plane_pos = plot_util.get_fig_rel_pos(ax, row_per_grp, axis="y")
    for plane, pos in zip(planes, plane_pos):
        fig.text(fig_xpos, pos, plane, rotation=90, fontsize="x-large", 
            verticalalignment="center", weight="bold")

    # adds line names (horizontal)
    line_pos = plot_util.get_fig_rel_pos(ax, col_per_grp, axis="x")
    for c, (line, pos) in enumerate(zip(lines, line_pos)):
        line_name = f"{line} Pyr" if len(line) and line[1].isdigit() else line
        if kind not in ["prog", "double_traces"] and col_per_grp == 1:
            ax[0, c].set_title(line_name, weight="bold", y=fig_ypos) 
        else:
            # get ypos based on plane positions
            fact = 0.5 * fig_ypos
            ypos = np.max(plane_pos) + np.absolute(np.diff(plane_pos)) * fact
            fig.text(pos, ypos, line_name, fontsize="x-large", 
                horizontalalignment="center", weight="bold")

    # add axis labels
    add_linpla_axislabels(ax, fluor=fluor, area=area, datatype=datatype, 
        x_ax=xlab, y_ax=ylab, single_lab=single_lab, kind=kind)


#############################################
def plot_ROI_values(sub_ax, masks, values, cm=None, no_marks=False, clims=None, 
                    savename=None):
    """
    plot_ROI_values(sub_ax, masks)

    Plots whole ROIs from a boolean mask, colour-coded by values.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
        - values (1D array)        : values for each ROI
    
    Optional args:
        - cm (colormap)   : a matplotlib colormap. If None, a default colormap 
                            is used.
                            default: None
        - no_marks (bool) : if True, all ticks and spines are removed
                            default: False
        - clims (list)    : colormap limits
                            default: None
        - savename (bool) : if provided, saves mask contours to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - masks_plot_proj (2D array): ROI image array: hei x wid
    """

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)
    
    values = np.asarray(values)
    if len(values) != len(masks):
        raise ValueError("Must provide as many values as masks.")

    if cm is None:
        color_list = ["blue", "white", "red"]
        cm = mplcol.LinearSegmentedColormap.from_list(
            "roi_mask_cm", color_list, N=100)
    
    vmin, vmax = None, None
    if clims is not None:
        vmin, vmax = clims
    
    masks = masks.astype(bool).astype(float)
    masks[masks == 0] = np.nan
    masks = masks * values.reshape(-1, 1, 1)
    with gen_util.TempWarningFilter("Mean of empty slice", RuntimeWarning):
        masks_plot_proj = np.nanmean(masks, axis=0)
        
    sub_ax.imshow(
        masks_plot_proj, cmap=cm, interpolation="none", vmin=vmin, vmax=vmax
        )

    if no_marks:
        plot_util.remove_axis_marks(sub_ax)

    if savename:
        plt.imsave(savename, masks_plot_proj, cmap=cm)

    return masks_plot_proj


#############################################
def plot_ROIs(sub_ax, masks, valid_mask=None, border=None, no_marks=False, 
              savename=None):
    """
    plot_ROIs(sub_ax, masks)

    Plots whole ROIs from a boolean mask, and optionally non valid
    ROIs in red.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    
    Optional args:
        - valid_mask (int): mask of valid ROIs (length of mask_bool). If None,
                            all ROIs plotted in white.
                            default: None
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - cm (colormap)   : a matplotlib colormap. If None, a default colormap 
                            is used.
                            default: None
        - no_marks (bool) : if True, all ticks and spines are removed
                            default: False
        - savename (bool) : if provided, saves mask contours to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - masks_plot_proj (2D array): ROI image array: hei x wid
    """

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)
    if valid_mask is None:
        valid_mask = np.ones(len(masks))

    color_list = ["black", "white", "red"]
    if valid_mask.all() and border is None:
        color_list = ["black", "white"]
    cm = mplcol.LinearSegmentedColormap.from_list(
        "roi_mask_cm", color_list, N=len(color_list))
    
    masks = masks.astype(bool).astype("int8")
    masks[~valid_mask.astype(bool)] *= 2
    masks_plot_proj = np.max(masks, axis=0)
    
    if border is not None:
        hei, wid = masks_plot_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]

        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        masks_plot_proj[hei_dash, right] = 2
        masks_plot_proj[hei_dash, wid-left] = 2
        masks_plot_proj[hei-down, wid_dash] = 2
        masks_plot_proj[up, wid_dash] = 2

    sub_ax.imshow(masks_plot_proj, cmap=cm, interpolation="none")

    if no_marks:
        plot_util.remove_axis_marks(sub_ax)

    if savename:
        plt.imsave(savename, masks_plot_proj, cmap=cm)

    return masks_plot_proj


#############################################
def plot_rec_proj(sub_ax, data, border=None, no_marks=False, savename=None):
    """
    plot_rec_proj(sub_ax, data)

    Plots scaled average projection of recording data in black and white.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - data (3D array)          : recording data, structured as
                                     frames x hei x wid
    
    Optional args:
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - no_marks (bool) : if True, all ticks and spines are removed
                            default: False
        - savename (bool) : if provided, saves masks to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - av_proj (2D array): data image array: hei x wid
    """

    if len(data.shape) == 2:
        data = np.expand_dims(data, 0)

    data_av = np.mean(data, axis=0)
    scale_min = np.min(data_av)
    scale_max = np.max(data_av)

    av_proj = (data_av - scale_min)/(scale_max - scale_min)

    color_list = ["black", "white", "red"]
    if border is None:
        color_list = ["black", "white"]
    cm = mplcol.LinearSegmentedColormap.from_list(
        "roi_mask_cm", color_list, N=100)
    
    if border is not None:
        hei, wid = av_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]
    
        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        av_proj[hei_dash, right] = 2
        av_proj[hei_dash, wid - left] = 2
        av_proj[hei - down, wid_dash] = 2
        av_proj[up, wid_dash] = 2

    sub_ax.imshow(av_proj, cmap=cm, interpolation="none")

    if no_marks:
        plot_util.remove_axis_marks(sub_ax)

    if savename:
        plt.imsave(savename, av_proj, cmap=cm)

    return av_proj


#############################################
def plot_ROIs_sep(sub_ax, masks, border=None, cm=None, no_marks=False, 
                  savename=None):
    """
    plot_ROIs_sep(sub_ax, masks)

    Plots whole ROIs from a boolean mask, and optionally non valid
    ROIs in red.

    Required args:
        - sub_ax (plt Axis subplot): subplot
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    
    Optional args:
        - border (list)   : border values to plot in red [right, left, down, up]
                            default: None
        - cm (plt cm)     : pyplot colormap. If None, a custom cmap is used.
                            default: None
        - no_marks (bool) : if True, all ticks and spines are removed
                            default: False
        - savename (bool) : if provided, saves masks to file 
                            (exact pixel size). ".png" best to avoid 
                            anti-aliasing.
                            default: False

    Returns:
        - masks_max_proj (2D array): ROI image array: hei x wid
    """

    masks = masks.astype(bool).astype("int8")

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)

    # each ROI gets a number, and the number of the smallest ROI is retained in 
    # the projection
    n_pix = np.sum(masks, axis=(1, 2))
    roi_vals = np.argsort(n_pix)[::-1].reshape(-1, 1, 1) + 1
    masks_max_proj = np.max(masks * roi_vals, axis=0)

    n_rois = masks.shape[0]
    add_border = (border is not None)

    if cm is None:
        color_list = np.ones([n_rois + 1 + add_border, 4])
        color_list[0, :-1] = 0
        col_spacing = np.linspace(0, 1, n_rois)
        color_list[1 : 1 + n_rois] = mpl.cm.get_cmap("gist_rainbow")(col_spacing)
        cm = mplcol.LinearSegmentedColormap.from_list(
            "roi_mask_col_cm", color_list, N=len(color_list))
    
    # numbers remapped to original order
    remap = np.insert(np.argsort(roi_vals.reshape(-1)) + 1, 0, 0)
    masks_max_proj = remap[masks_max_proj]
    
    if border is not None:
        hei, wid = masks_max_proj.shape
        right, left, down, up = [
            np.ceil(border[i]).astype("int8") for i in [0, 1, 2, 3]]
    
        # create dash patterns
        dash_len = 3
        hei_dash, wid_dash = [np.concatenate(
            [np.arange(i, v, dash_len * 2) for i in range(dash_len)]) 
            for v in [hei, wid]]

        masks_max_proj[hei_dash, right] = n_rois + 1
        masks_max_proj[hei_dash, wid - left] = n_rois + 1
        masks_max_proj[hei - down, wid_dash] = n_rois + 1
        masks_max_proj[up, wid_dash] = n_rois + 1

    sub_ax.imshow(masks_max_proj, cmap=cm, interpolation="none")

    if no_marks:
        plot_util.remove_axis_marks(sub_ax)

    if savename:
        plt.imsave(savename, masks_max_proj, cmap=cm)

    return masks_max_proj


#############################################
def plot_ROI_contours(sub_ax, masks, outlier=None, tight=False, 
                      restrict=False, cw=1, outer=False, cm=None, 
                      no_marks=False, savename=False):
    """
    plot_ROI_contours(sub_ax, masks)

    Plots and returns ROI contours from a boolean mask, and optionally an 
    outlier in red. Optionally saves ROI contours to file.

    Required args:
        - sub_ax (plt Axis subplot): subplot (if None, masks are not plotted)
        - masks (3D array)         : boolean ROI masks, structured as
                                     ROIs x hei x wid
    Optional args:
        - outlier (int)  : index of ROI, if any, for which to plot contour 
                           in a red.
                           default: None
        - tight (bool)   : if True, plot is restricted to the ROIs in the mask,
                           allowing for a 15% border, where possible
                           default: False
        - restrict (bool): if True, plot is restricted to the outlier ROI,
                           allowing for a 150% border, where possible. 
                           Overrides right.
                           default: True
        - cw (int)       : contour width (in pixels) (always within the ROI, 
                           unless outer)
                           default: 1
        - outer (bool)   : if True, the contours are drawn outside the ROI 
                           boundaries, instead of within
                           default: False
        - cm (plt cm)    : pyplot colormap. If None, a custom cmap is used.
                           default: None
        - no_marks (bool): if True, all ticks and spines are removed
                           default: False
        - savename (bool): if provided, saves mask contours to file 
                           (exact pixel size). ".png" best to avoid 
                           anti-aliasing.
                           default: False

    Returns:
        - contour_mask (2D array): ROI contour image array: hei x wid
    """

    if cm is None:
        color_list = ["black", "white", "red"]
        if outlier is None:
            color_list = ["black", "white"]
        cm = mplcol.LinearSegmentedColormap.from_list(
            "roi_mask_cm", color_list, N=len(color_list))

    if len(masks.shape) == 2:
        masks = np.expand_dims(masks, 0)
    masks = np.ceil(masks).astype("int8")
    _, h_orig, w_orig = masks.shape

    if outlier is None and restrict:
        raise ValueError("'restrict' requires providing an outlier.")

    if tight or restrict:
        dims = h_orig, w_orig
        if restrict:
            border_p = 1.5
            dim_vals = np.where(masks[outlier])
            r_val = 1
        else:
            border_p = 0.15
            dim_vals = np.where(masks.sum(axis=0))
            r_val = 0
        dim_mins = [val.min() for val in dim_vals]
        dim_maxs = [val.max() for val in dim_vals]
        borders = [int(np.ceil(border_p * (dmax - dmin))) 
            for dmin, dmax in zip(dim_mins, dim_maxs)]
        h_min, w_min = [np.max([0, val - bord - r_val]) 
            for val, bord in zip(dim_mins, borders)]
        h_max, w_max = [np.min([d, val + bord + r_val]) 
            for val, bord, d in zip(dim_maxs, borders, dims)]
        masks = masks[:, h_min:h_max, w_min:w_max]

    pad_zhw = [0, 0], [cw, cw], [cw, cw]
    contour_mask = np.pad(masks, pad_zhw, "constant", constant_values=0)
    shifts = range(-cw, cw + 1)
    _, h, w = masks.shape
    for h_sh, w_sh in itertools.product(shifts, repeat=2):
        if h_sh == 0 and w_sh == 0:
            continue
        contour_mask[:, cw+h_sh: h+cw+h_sh, cw+w_sh: w+cw+w_sh] += masks
    
    sub_mask = contour_mask[:, cw:h+cw, cw:w+cw]
    contour_mask = (sub_mask != len(shifts) ** 2) * (sub_mask != 0)
    if outer:
        restrict_masks = 1 - masks
    else:
        restrict_masks = masks
    contour_mask = contour_mask * restrict_masks
    del masks

    if restrict:
        dim_vals = [h_min, h_max, w_min, w_max]
        comps = [0, h_orig, 0, w_orig]
        shifts = [0, 0, 0, 0]
        for i, (val, comp) in enumerate(zip(dim_vals, comps)):
            if val != comp:
                shifts[i] = r_val
        contour_mask = contour_mask[
            :, shifts[0]:comps[1] - shifts[1], shifts[2]:comps[3] - shifts[3]]
    
    mult_mask = np.ones([len(contour_mask), 1, 1])
    if outlier is not None:
        mult_mask[outlier] = 2
    contour_mask = np.max(contour_mask * mult_mask, axis=0)

    if sub_ax is not None:
        sub_ax.imshow(contour_mask, cmap=cm, interpolation="none")

    if no_marks:
        plot_util.remove_axis_marks(sub_ax)

    if savename:
        plt.imsave(savename, contour_mask, cmap=cm)

    return contour_mask

