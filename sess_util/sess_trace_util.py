"""
sess_trace_util.py

This module contains functions for processing ROI trace data from files 
generated by the Allen Institute OpenScope experiments for the Credit 
Assignment Project.

Authors: Colleen Gillon

Date: August, 2018

Note: this code uses python 3.7.

"""

"""
sess_trace_util.py

This module contains functions for handling ROI traces of the Allen Institute 
OpenScope experiments for the Credit Assignment Project.

Authors: Allen Brain Institute, Joel Zylberberg, Blake Richards, Colleen Gillon

Date: August, 2018

Note: this code uses python 3.7.

"""

import copy

import json
import numpy as np
import pandas as pd
import pynwb

from util import logger_util
from sess_util import sess_file_util


MASK_THRESHOLD = 0.1 # value used in ROI extraction
MIN_N_PIX = 3 # value used in ROI extraction


logger = logger_util.get_module_logger(name=__name__)


#############################################
def load_traces_optimally(roi_data_handle, roi_ns=None, frame_ns=None, 
                          rois_first=True):
    """
    load_traces_optimally(roi_data_handle)

    Updates indices, possibly reordered, for optimal loading of ROI traces.

    Optional args:
        - roi_ns (int or array-like)  : ROIs to load (None for all)
                                        default: None
        - frame_ns (int or array-like): frames to load (None for all) 
                                        default: None
        - rois_first (bool)           : if True, ROIs are stored as 
                                        ROIs x frames, else frames x ROIs
                                        default: True

    Returns:
        - roi_traces (1 or 2D array): ROI traces (ROI x frame)
    """

    # if no ROIs are specified
    if roi_ns is None and frame_ns is None:
        roi_traces = roi_data_handle[()]


    # if ROI_ns is an int
    elif isinstance(roi_ns, int):
        if rois_first:
            roi_traces = roi_data_handle[roi_ns]
        else:
            roi_traces = roi_data_handle[:, roi_ns]
        if frame_ns is not None:
            roi_traces = roi_traces[frame_ns]
        

    # if frame_ns is an int
    elif isinstance(frame_ns, int):
        if rois_first:
            roi_traces = roi_data_handle[:, frame_ns]
        else:
            roi_traces = roi_data_handle[frame_ns]
        if roi_ns is not None:
            roi_traces = roi_traces[roi_ns]


    # if both are vectors, if possible, load frames, then select ROIs
    elif frame_ns is not None and (len(np.unique(frame_ns)) == len(frame_ns)):
        if roi_ns is None:
            roi_ns = slice(None, None, None)
        frame_ns = np.asarray(frame_ns)
        resort = None
        if (np.sort(frame_ns) != frame_ns).any(): # sort if not sorted
            resort = np.argsort(np.argsort(frame_ns))
            frame_ns = np.sort(frame_ns)
        if rois_first:
            roi_traces = roi_data_handle[:, frame_ns][roi_ns]
            if resort is not None:
                roi_traces = roi_traces[:, resort]
        else:
            roi_traces = roi_data_handle[frame_ns][..., roi_ns]
            if resort is not None:
                roi_traces = roi_traces[resort]


    # alternatively, if possible, load ROIs, then select frames    
    elif roi_ns is not None and len(np.unique(roi_ns)) == len(roi_ns):
        if frame_ns is None:
            frame_ns = slice(None, None, None)
        roi_ns = np.asarray(roi_ns)
        resort = None
        if (np.sort(roi_ns) != roi_ns).any(): # sort if not sorted
            resort = np.argsort(np.argsort(roi_ns))
            roi_ns = np.sort(roi_ns)
        if rois_first:
            roi_traces = roi_data_handle[roi_ns][:, frame_ns]
            if resort is not None:
                roi_traces = roi_traces[resort]
        else:
            roi_traces = roi_data_handle[:, roi_ns][frame_ns]
            if resort is not None:
                roi_traces = roi_traces[:, resort]


    # load fully and select
    else:
        if roi_ns is None:
            roi_ns = slice(None, None, None)
        if frame_ns is None:
            frame_ns = slice(None, None, None)
        if rois_first:
            roi_traces = roi_data_handle[()][roi_ns][:, frame_ns]
        else:
            roi_traces = roi_data_handle[()][:, roi_ns][frame_ns]


    if not rois_first:
        roi_traces = roi_traces.T

    return roi_traces


#############################################
def load_roi_traces_nwb(sess_files, roi_ns=None, frame_ns=None):
    """
    load_roi_traces_nwb(sess_files)

    Returns ROI traces from NWB files (stored as frames x ROIs). 

    Required args:
        - sess_files (list): full path names of the session files

    Optional args:
        - roi_ns (int or array-like)  : ROIs to load (None for all)
                                        default: None
        - frame_ns (int or array-like): frames to load (None for all) 
                                        default: None

    Returns:
        - roi_traces (1 or 2D array): ROI traces (ROI x frame)
    """

    ophys_file = sess_file_util.select_nwb_sess_path(sess_files, ophys=True)

    with pynwb.NWBHDF5IO(str(ophys_file), "r") as f:
        nwbfile_in = f.read()
        ophys_module = nwbfile_in.get_processing_module("ophys")
        main_field = "DfOverF"
        data_field = "RoiResponseSeries"
        try:
            roi_resp_series = ophys_module.get_data_interface(
                main_field).get_roi_response_series(data_field
                )
        except KeyError as err:
            raise KeyError(
                "Could not find ROI response series data in image segmentation "
                f"for {ophys_file} due to: {err}"
                )

        roi_data_handle = roi_resp_series.data

        roi_traces = load_traces_optimally(
            roi_data_handle, roi_ns=roi_ns, frame_ns=frame_ns, 
            rois_first=False,
            )


    return roi_traces


#############################################
def load_roi_data_nwb(sess_files):
    """
    load_roi_data_nwb(sess_files)

    Returns ROI data from NWB files. 

    Required args:
        - sess_files (Path): full path names of the session files

    Returns:
        - roi_ids (list)   : ROI IDs
        - nrois (int)      : total number of ROIs
        - tot_twop_fr (int): total number of two-photon frames recorded
    """

    ophys_file = sess_file_util.select_nwb_sess_path(sess_files, ophys=True)

    with pynwb.NWBHDF5IO(str(ophys_file), "r") as f:
        nwbfile_in = f.read()
        ophys_module = nwbfile_in.get_processing_module("ophys")
        main_field = "ImageSegmentation"
        data_field = "PlaneSegmentation"
        try:
            plane_seg = ophys_module.get_data_interface(
                main_field).get_plane_segmentation(data_field
                )
        except KeyError as err:
            raise KeyError(
                "Could not find plane segmentation data in image segmentation "
                f"for {ophys_file} due to: {err}"
                )

        # ROI IDs
        roi_ids = list(plane_seg["id"].data)

        # Number of ROIs and frames
        main_field = "DfOverF"
        data_field = "RoiResponseSeries"
        try:
            roi_resp_series = ophys_module.get_data_interface(
                main_field).get_roi_response_series(data_field
                )
        except KeyError as err:
            raise KeyError(
                "Could not find ROI response series data in image segmentation "
                f"for {ophys_file} due to: {err}"
                )

        tot_twop_fr, nrois = roi_resp_series.data.shape


    return roi_ids, nrois, tot_twop_fr


#############################################
def get_tracked_rois(nway_match_path, idx_after_rem_bad=False):
    """
    get_tracked_rois(nway_match_path)

    Returns ROI tracking indices.

    Required args:
        - nway_match_path (Path): path to nway matching file
        
    Optional args:
        - idx_after_rem_bad (bool): if True, the ROI indices are shifted to 
                                    as if bad ROIs did not exist
                                    (bad ROIs computed for dF/F only)
                                    default: False

    Returns:
        - tracked_rois (1D array): ordered indices of tracked ROIs
    """

    with open(nway_match_path, "r") as f:
        nway_dict = json.load(f)

    tracked_rois_df = pd.DataFrame().from_dict(nway_dict["rois"])
    tracked_rois = tracked_rois_df['dff-ordered_roi_index'].values
    
    if idx_after_rem_bad:
        bad_rois_df = pd.DataFrame().from_dict(nway_dict["bad_rois"])
        bad_rois = bad_rois_df["dff_local_bad_roi_idx"].values

        # shift indices to ignore bad ROIs
        adj_tracked_rois = []
        for n in tracked_rois:
            adj_tracked_rois.append(n - np.sum(bad_rois < n))
        tracked_rois = np.asarray(adj_tracked_rois)

    return tracked_rois


#############################################
def get_tracked_rois_nwb(sess_files):
    """
    get_tracked_rois_nwb(sess_files)

    Returns ROI tracking indices.

    Required args:
        - sess_files (list): full path names of the session files
        
    Returns:
        - tracked_rois (1D array): ordered indices of tracked ROIs
    """

    ophys_file = sess_file_util.select_nwb_sess_path(sess_files, ophys=True)

    with pynwb.NWBHDF5IO(str(ophys_file), "r") as f:
        nwbfile_in = f.read()
        ophys_module = nwbfile_in.get_processing_module("ophys")
        main_field = "ImageSegmentation"
        data_field = "PlaneSegmentation"
        try:
            plane_seg = ophys_module.get_data_interface(
                main_field).get_plane_segmentation(data_field
                )
        except KeyError as err:
            raise KeyError(
                "Could not find plane segmentation data in image segmentation "
                f"for {ophys_file} due to: {err}"
                )

        tracking_key = "tracking_id"
        if tracking_key not in plane_seg.colnames:
            raise RuntimeError(f"No tracking data in {ophys_file}.")

        # tracking index for each ROI (np.nan for non tracked ROIs)
        roi_tracking = np.asarray(plane_seg[tracking_key].data)

    tracked_idxs = np.where(np.isfinite(roi_tracking))[0]
    tracking_order = np.argsort(roi_tracking[tracked_idxs])

    # ordered indices of tracked ROIs
    tracked_rois = tracked_idxs[tracking_order]

    return tracked_rois


#############################################
def process_roi_masks(roi_masks, mask_threshold=MASK_THRESHOLD, 
                      min_n_pix=MIN_N_PIX, make_bool=True):
    """
    process_roi_masks(roi_masks)

    Processes ROI masks, setting to 0 those that do not meet the input 
    criteria.

    Required args:
        - roi_masks (3D): ROI masks (ROI x hei x wid)

    Optional args:
        - mask_threshold (float): minimum value in non-boolean mask to
                                  retain a pixel in an ROI mask
                                  default: MASK_THRESHOLD
        - min_n_pix (int)       : minimum number of pixels in an ROI below 
                                  which, ROI is set to be empty (calculated 
                                  before conversion to boolean, using weighted 
                                  pixels)
                                  default: MIN_N_PIX
        - make_bool (bool)      : if True, ROIs are converted to boolean 
                                  before being returned
                                  default: True 

    Returns:
        - roi_masks (3D): processed ROI masks (ROI x hei x wid)
    """

    roi_masks = copy.deepcopy(roi_masks)

    if len(roi_masks.shape) != 3:
        raise ValueError("roi_masks should have 3 dimensions.")

    roi_masks[roi_masks < mask_threshold] = 0

    if min_n_pix != 0:
        set_empty = np.sum(roi_masks, axis=(1, 2)) < min_n_pix
        roi_masks[set_empty] = 0

    if make_bool:
        roi_masks = roi_masks.astype(bool)
    
    return roi_masks


#############################################
def get_roi_masks_nwb(sess_files, mask_threshold=MASK_THRESHOLD, 
                      min_n_pix=MIN_N_PIX, make_bool=True):
    """
    get_roi_masks_nwb(sess_files)

    Returns tracked ROIs, optionally converted to boolean.

    Required args:
        - sess_files (Path): full path names of the session files

    Optional args:
        - mask_threshold (float): minimum value in non-boolean mask to
                                  retain a pixel in an ROI mask
                                  default: MASK_THRESHOLD
        - min_n_pix (int)       : minimum number of pixels in an ROI below 
                                  which, ROI is set to be empty (calculated 
                                  before conversion to boolean, using weighted 
                                  pixels)
                                  default: MIN_N_PIX
        - make_bool (bool)      : if True, ROIs are converted to boolean 
                                  before being returned
                                  default: True 
        
    Returns:
        - roi_masks (3D array): ROI masks, structured as 
                                ROI x height x width
        - roi_ids (list)      : ID for each ROI
    """

    ophys_file = sess_file_util.select_nwb_sess_path(sess_files, ophys=True)

    with pynwb.NWBHDF5IO(str(ophys_file), "r") as f:
        nwbfile_in = f.read()
        ophys_module = nwbfile_in.get_processing_module("ophys")
        main_field = "ImageSegmentation"
        data_field = "PlaneSegmentation"
        try:
            plane_seg = ophys_module.get_data_interface(
                main_field).get_plane_segmentation(data_field
                )
        except KeyError as err:
            raise KeyError(
                "Could not find plane segmentation data in image segmentation "
                f"for {ophys_file} due to: {err}"
                )

        roi_masks = np.asarray(plane_seg["image_mask"].data)
        roi_ids = list(plane_seg["id"].data)

    roi_masks = process_roi_masks(
        roi_masks, mask_threshold=mask_threshold, min_n_pix=min_n_pix, 
        make_bool=make_bool
        )

    return roi_masks, roi_ids
