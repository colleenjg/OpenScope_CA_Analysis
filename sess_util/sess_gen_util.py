"""
sess_gen_util.py

This module contains general functions for navigating data generated by 
the Allen Institute OpenScope experiments for the Credit Assignment Project.

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 3.7.

"""

import copy
from pathlib import Path

import numpy as np
import pandas as pd

from util import file_util, gen_util, logger_util


logger = logger_util.get_module_logger(name=__name__)


#############################################
def get_param_vals(param="gabk", gabfr_lett=False):
    """
    get_param_vals()

    Returns all possible parameter values for the requested parameter.

    Optional args:
        - param (str)      : parameter name
                             default: "gabk"
    
        - gabfr_lett (bool): if True, and gabor frames are requested, 
                             Gabor frame letters (A, B, C, D, U, G) are 
                             returned instead of numbers (0, 1, 2, 3, 4)
                             default: False

    Returns:
        - param_vals (list): parameter values
    """
    
    if param in ["gabk", "gabor_kappa"]:
        param_vals = [4, 16]
    elif param in ["gab_ori", "gabor_orientation", "gabor_mean_orientation"]:
        param_vals = [0, 45, 90, 135, 180, 225]
    elif param in ["gabfr", "gabor_frame"]:
        if gabfr_lett:
            param_vals = ["A", "B", "C", "D", "U", "G"]
        else:
            param_vals = [0, 1, 2, 3, 4]
    elif param in ["gabor_number", "gab_nbr"]:
        param_vals = [30]
    elif param in ["visflow_size", "square_size"]:
        param_vals = [128, 256]
    elif param in ["visflow_number", "square_number"]:
        param_vals = [105, 26]
    elif param in ["visflow_dir", "main_flow_direction"]:
        param_vals = [
            get_visflow_screen_mouse_direc(direc) for direc in ["right", "left"]
            ]
    elif param in ["square_proportion_flipped"]:
        param_vals = [0, 0.25]
    else:
        raise ValueError(f"{param} not recognized as a parameter.")

    return param_vals


#############################################
def depth_vals(plane, line):
    """
    depth_vals(plane, line)

    Returns depth values corresponding to a specified plane.

    Required args:
        - plane (str): plane (e.g., "dend", "soma", "any")
        - line (str) : line (e.g., "L23", "L5", "any")
    Returns:
        - depths (str or list): depths corresponding to plane and line or "any"
    """

    if plane in ["any", "all"] and line in ["any", "all"]:
        return "any"
    
    depth_dict = {"L23_dend": [50, 75],
                  "L23_soma": [175],
                  "L5_dend" : [20],
                  "L5_soma" : [375]
                 }

    all_planes = ["dend", "soma"]
    if plane in ["any", "all"]:
        planes = all_planes
    else:
        planes = gen_util.list_if_not(plane)
    
    all_lines = ["L23", "L5"]
    if line in ["any", "all"]:
        lines = all_lines
    else:
        lines = gen_util.list_if_not(line)
    
    depths = []
    for plane in planes:
        if plane not in all_planes:
            allowed_planes = all_planes + ["any", "all"]
            gen_util.accepted_values_error("plane", plane, allowed_planes)
        for line in lines:
            if line not in all_lines:
                allowed_lines = all_lines + ["any", "all"]
                gen_util.accepted_values_error("line", line, allowed_lines)
            depths.extend(depth_dict[f"{line}_{plane}"])

    return depths


#############################################
def get_mouse_df_vals(mouse_df, returnlab, mouse_n, sessid, sess_n, runtype, 
                      depth, pass_fail="P", incl="yes", all_files=1, 
                      any_files=1, min_rois=1, unique=False, sort=False):
    """
    get_mouse_df_vals(mouse_df, returnlab, mouse_n, sessid, sess_n, runtype, 
                      depth)

    Returns values from mouse dataframe under a specified label or labels that 
    fit the criteria.

    Required args:
        - mouse_df (pandas df)      : dataframe containing parameters for each 
                                      session.
        - returnlab (str or list)   : labels for which to return values
        - mouse_n (int, str or list): mouse id value(s) of interest  
        - sessid (int or list)      : session id value(s) of interest
        - sess_n (int, str or list) : session number(s) of interest
        - runtype (str or list)     : runtype value(s) of interest       
        - depth (str or list)       : depth value(s) of interest (20, 50, 75,  
                                      175, 375)

    Optional args:
        - pass_fail (str or list)     : pass/fail values of interest ("P", "F")
                                        default: "P"
        - incl (str)                  : which sessions to include ("yes", "no", 
                                        "any")
                                        default: "yes"
        - all_files (int, str or list): all_files values of interest (0, 1)
                                        default: 1
        - any_files (int, str or list): any_files values of interest (0, 1)
                                        default: 1
        - min_rois (int)              : min number of ROIs
                                        default: 1
        - unique (bool)               : whether to return a list of values 
                                        without duplicates
                                        default: False 
        - sort (bool)                 : whether to sort output values
                                        default: False
                                    
    Returns:
        - df_vals (list): list of values under the specified labels that fit
                          the criteria (or list of lists in multiple labels)
    """

    # make sure all of these labels are lists
    all_labs = [mouse_n, sessid, sess_n, runtype, depth, pass_fail, 
                incl, all_files, any_files]
    all_cols = ["mouse_n", "sessid", "sess_n", "runtype", "depth", "pass_fail", 
                "incl", "all_files", "any_files"]
    for i in range(len(all_labs)):
        all_labs[i] = gen_util.list_if_not(all_labs[i])
        col_dtype = mouse_df[all_cols[i]].dtype
        if col_dtype in [bool, int, float]:
            all_labs[i] = gen_util.conv_types(all_labs[i])


    [mouse_n, sessid, sess_n, runtype, depth, 
        pass_fail, incl, all_files, any_files] = all_labs

    df_rows = mouse_df.loc[
        (mouse_df["mouse_n"].isin(mouse_n)) & 
        (mouse_df["sessid"].isin(sessid)) &
        (mouse_df["sess_n"].isin(sess_n)) &
        (mouse_df["runtype"].isin(runtype)) &
        (mouse_df["depth"].isin(depth)) &
        (mouse_df["pass_fail"].isin(pass_fail)) &
        (mouse_df["incl"].isin(incl)) &
        (mouse_df["all_files"].isin(all_files)) &
        (mouse_df["any_files"].isin(any_files)) &
        (mouse_df["nrois"].astype(int) >= min_rois)]

    returnlab = gen_util.list_if_not(returnlab)
    if len(returnlab) != 1 and (sort or unique):
        logger.warning("Sorted and unique will be set to False as multiple "
            "labels are requested.")
        sort   = False
        unique = False
    
    df_vals = []
    for lab in returnlab:
        vals = df_rows[lab].tolist()
        if unique:
            vals = list(set(vals))
        if sort:
            vals = sorted(vals)
        df_vals.append(vals)
        
    df_vals = gen_util.delist_if_not(df_vals)

    return df_vals


#############################################
def get_sess_vals(mouse_df, returnlab, mouse_n="any", sess_n="any", 
                  runtype="any", plane="any", line="any", pass_fail="P", 
                  incl="all", all_files=1, any_files=1, min_rois=1, 
                  omit_sess=[], omit_mice=[], unique=True, sort=False):
    """
    get_sess_vals(mouse_df, returnlab)

    Returns list of values under the specified label that fit the specified
    criteria.

    Required args:
        - mouse_df (Path)        : path name of dataframe containing 
                                   information on each session
        - returnlab (str or list): label(s) from which to return values

    Optional args:
        - mouse_n (int, str or list)  : mouse number(s) of interest
                                        default: "any"
        - sess_n (int, str or list)   : session number(s) of interest
                                        default: "any"
        - runtype (str or list)       : runtype value(s) of interest
                                        ("pilot", "prod")
                                        default: "any"
        - plane (str or list)         : plane value(s) of interest
                                        ("soma", "dend", "any")
                                        default: "any"
        - line (str or list)          : line value(s) of interest
                                        ("L5", "L23", "any")
                                        default: "any"
        - pass_fail (str or list)     : pass/fail values of interest 
                                        ("P", "F", "any")
                                        default: "P"
        - incl (str)                  : which sessions to include ("yes", "no", 
                                        "any")
                                        default: "yes"
        - all_files (str, int or list): all_files values of interest (0, 1)
                                        default: 1
        - any_files (str, int or list): any_files values of interest (0, 1)
                                        default: 1
        - min_rois (int)              : min number of ROIs
                                        default: 1
        - omit_sess (list)            : sessions to omit
                                        default: []
        - omit_mice (list)            : mice to omit
                                        default: []
        - unique (bool)               : whether to return a list of values 
                                        without duplicates (only done if only 
                                        one returnlab is provided)
                                        default: False 
        - sort (bool)                 : whether to sort output values (only 
                                        done if only one returnlab is provided)
                                        default: False
     
    Returns:
        - sess_vals (list): values from dataframe that correspond to criteria
    """

    if isinstance(mouse_df, (str, Path)):
        mouse_df = file_util.loadfile(mouse_df)

    # get depth values corresponding to the plane
    depth = depth_vals(plane, line)

    sessid      = "any"
    params      = [mouse_n, sessid, sess_n, runtype, depth, pass_fail, incl, 
        all_files, any_files]
    param_names = ["mouse_n", "sessid", "sess_n", "runtype", "depth",
        "pass_fail", "incl", "all_files", "any_files"]
    
    # for each label, collect values in a list
    for i in range(len(params)):
        params[i] = gen_util.get_df_label_vals(
            mouse_df, param_names[i], params[i])   
    [mouse_n, sessid, sess_n, runtype, depth,  
        pass_fail, incl, all_files, any_files] = params

    # remove omitted sessions from the session id list
    sessid = gen_util.remove_if(sessid, omit_sess)
    
    # collect all mouse IDs and remove omitted mice
    mouse_n = gen_util.remove_if(mouse_n, omit_mice)

    sess_vals = get_mouse_df_vals(mouse_df, returnlab, mouse_n, sessid, sess_n, 
        runtype, depth, pass_fail, incl, all_files, 
        any_files, min_rois, unique, sort)

    return sess_vals


#############################################
def sess_per_mouse(mouse_df, mouse_n="any", sess_n=1, runtype="prod", 
                   plane="any", line="any", pass_fail="P", incl="yes",
                   all_files=1, any_files=1, min_rois=1, closest=False, 
                   omit_sess=[], omit_mice=[]):
    """
    sess_per_mouse(mouse_df)
    
    Returns list of session IDs (up to 1 per mouse) that fit the specified
    criteria.

    Required args:
        - mouse_df (Path): path name of dataframe containing information 
                           on each session
        
    Optional args:
        - mouse_n (int or str)   : mouse number(s) of interest
                                   default: "any"
        - sess_n (int or str)    : session number(s) of interest
                                   (1, 2, 3, ... or "first", "last")
                                   default: 1
        - runtype (str or list)  : runtype value(s) of interest
                                   ("pilot", "prod")
                                   default: "prod"
        - plane (str or list)    : plane value(s) of interest
                                   ("soma", "dend", "any")
                                   default: "any"
        - line (str or list)     : line value(s) of interest
                                   ("L5", "L23", "any")
                                   default: "any"
        - pass_fail (str or list): pass/fail values of interest 
                                   ("P", "F", "any")
                                   default: "P"
        - incl (str)             : which sessions to include ("yes", "no", 
                                   "any")
                                   default: "yes"
        - all_files (int or list): all_files values of interest (0, 1)
                                   default: 1
        - any_files (int or list): any_files values of interest (0, 1)
                                   default: 1
        - min_rois (int)         : min number of ROIs
                                   default: 1
        - closest (bool)         : if False, only exact session number is 
                                   retained, otherwise the closest
                                   default: False
        - omit_sess (list)       : sessions to omit
                                   default: []
        - omit_mice (list)       : mice to omit
                                   default: []
     
    Returns:
        - sessids (list): sessions to analyse (1 per mouse)
    """
    
    if isinstance(mouse_df, (str, Path)):
        mouse_df = file_util.loadfile(mouse_df)
        
    orig_sess_n = int(sess_n)
    if closest or str(sess_n) in ["first", "last", "-1"]:
        sess_n = gen_util.get_df_label_vals(mouse_df, "sess_n", "any")
    
    if runtype == "any":
        raise ValueError("Must specify runtype (cannot be any), as there is "
            "overlap in mouse numbers.")

    # get list of mice that fit the criteria
    mouse_ns = get_sess_vals(
        mouse_df, "mouse_n", mouse_n, sess_n, runtype,  plane, line, pass_fail, 
        incl, all_files, any_files, min_rois, omit_sess, omit_mice, 
        unique=True, sort=True)

    # get session ID each mouse based on criteria 
    sessids = []
    for i in sorted(mouse_ns):
        sess_ns = get_sess_vals(
            mouse_df, "sess_n", i, sess_n, runtype, plane, line, pass_fail, 
            incl, all_files, any_files, min_rois, omit_sess, omit_mice, 
            sort=True)
        # skip mouse if no sessions meet criteria
        if len(sess_ns) == 0:
            continue
        # if only exact sess n is accepted (not closest)
        elif str(orig_sess_n) == "first" or not closest:
            n = sess_ns[0]
        elif str(orig_sess_n) in ["last", "-1"]:
            n = sess_ns[-1]
        # find closest sess number among possible sessions
        else:
            n = sess_ns[np.argmin(
                np.absolute([x - orig_sess_n for x in sess_ns]))]
        sessid = get_sess_vals(
            mouse_df, "sessid", i, n, runtype, plane, line, pass_fail, incl, 
            all_files, any_files, min_rois, omit_sess, omit_mice)[0]
        sessids.append(sessid)
    
    if len(sessids) == 0:
        raise RuntimeError("No sessions meet the criteria.")

    return sessids


#############################################
def sess_comp_per_mouse(mouse_df, mouse_n="any", sess_n="1v2", runtype="prod", 
                        plane="any", line="any", pass_fail="P", incl="yes", 
                        all_files=1, any_files=1, min_rois=1, closest=False, 
                        omit_sess=[], omit_mice=[]):
    """
    sess_comp_per_mouse(mouse_df)
    
    Returns list of session ID combinations (2 per mouse) that fit the 
    specified criteria.

    Required args:
        - mouse_df (Path): path name of dataframe containing information 
                           on each session
        
    Optional args:
        - mouse_n (int or str)   : mouse number(s) of interest
                                   default: "any"
        - sess_n (int or str)    : session numbers of interest to compare
                                   default: "1v2"
        - runtype (str or list)  : runtype value(s) of interest
                                   ("pilot", "prod")
                                   default: "prod"
        - plane (str or list)    : plane value(s) of interest
                                   ("soma", "dend", "any")
                                   default: "any"
        - line (str or list)     : line value(s) of interest
                                   ("L5", "L23", "any")
                                   default: "any"
        - pass_fail (str or list): pass/fail values of interest 
                                   ("P", "F", "any")
                                   default: "P"
        - incl (str)             : which sessions to include ("yes", "no", 
                                   "any")
                                   default: "yes"
        - all_files (int or list): all_files values of interest (0, 1)
                                   default: 1
        - any_files (int or list): any_files values of interest (0, 1)
                                   default: 1
        - min_rois (int)         : min number of ROIs
                                   default: 1
        - closest (bool)         : if False, only exact session number is 
                                   retained, otherwise the closest
                                   default: False
        - omit_sess (list)       : sessions to omit
                                   default: []
        - omit_mice (list)       : mice to omit
                                   default: []
     
    Returns:
        - sessids (list): session combinations to analyse, structured as 
                              mouse x sess
    """

    if closest:
        logger.info("Session comparisons not implemented using the 'closest' "
            "parameter. Setting to False.")
        closest = False

    if "v" not in str(sess_n):
        raise ValueError("sess_n must be of a format like '1v3'.")

    sess_n = [n for n in sess_n.split("v")]
    for i in range(len(sess_n)):
        if sess_n[i] not in ["first", "last"]:
            sess_n[i] = int(sess_n[i])

    if runtype == "any":
        raise ValueError("Must specify runtype (cannot be any), as there is "
            "overlap in mouse numbers.")

    # get list of mice that fit the criteria
    mouse_ns = []
    for n in sess_n:
        if str(n) in ["last", "-1"]:
            n = "any"
        ns = get_sess_vals(
            mouse_df, "mouse_n", mouse_n, n, runtype, plane, line, pass_fail, 
            incl, all_files, any_files, min_rois, omit_sess, omit_mice, 
            unique=True, sort=True)
        mouse_ns.append(ns)
    
    mouse_ns = set(mouse_ns[0]).intersection(set(mouse_ns[1]))

    # get session ID each mouse based on criteria 
    sessids = []
    for i in mouse_ns:
        mouse_sessids = []
        for j, n in enumerate(sess_n):
            if str(n) in ["first", "last", "-1"]:
                ns = get_sess_vals(
                    mouse_df, "sess_n", i, "any", runtype, plane, line, 
                    pass_fail, incl, all_files, any_files, min_rois, omit_sess, 
                    omit_mice, sort=True)[-1]
                if len(ns) == 0 or ns[-1] == sess_n[1-j]:
                    break # mouse omitted
                if n == "first":
                    n = ns[0]
                else:
                    n = ns[-1]
            sessid = get_sess_vals(
                mouse_df, "sessid", i, n, runtype, plane, line, pass_fail, 
                incl, all_files, any_files, min_rois, omit_sess, omit_mice)[0]
            mouse_sessids.append(sessid)
        sessids.append(mouse_sessids)
    
    if len(sessids) == 0:
        raise RuntimeError("No session combinations meet the criteria.")

    return sessids


#############################################
def init_sessions(sessids, datadir, mouse_df, runtype="prod", full_table=True, 
                  fluor="dff", dend="extr", omit=False, roi=True, run=False, 
                  pupil=False, temp_log=None):
    """
    init_sessions(sessids, datadir)

    Creates list of Session objects for each session ID passed.

    Required args:
        - sessids (int or list): ID or list of IDs of sessions
        - datadir (Path)       : directory where sessions are stored
        - mouse_df (Path)      : path name of dataframe containing information 
                                 on each session

    Optional args:
        - runtype (str)    : the type of run, either "pilot" or "prod"
                             default: "prod"
        - full_table (bool): if True, the full stimulus dataframe is loaded 
                             (with all the visual flow square positions and 
                             individual Gabor patch orientations).
                             default: True
        - dend (str)       : type of dendrites to use ("allen" or "extr")
                             default: "extr"
        - omit (bool)      : if True, dendritic sessions with the wrong type of 
                             dendrite are omitted
                             default: False
        - roi (bool)       : if True, ROI data is loaded into sessions
                             default: True
        - run (bool)       : if True, running data is loaded into sessions
                             default: False
        - pupil (bool)     : if True, pupil data is loaded into session and 
                             only sessions with pupil data are included
                             default: False
        - temp_log (bool)  : temporary log level to set logger to. If None, 
                             logger is left at current level.
                             default: None

    Returns:
        - sessions (list): list of Session objects
    """

    from analysis import session
    
    with logger_util.TempChangeLogLevel(level=temp_log):
        sessions = []
        sessids = gen_util.list_if_not(sessids)
        for sessid in sessids:
            logger.info(
                f"Creating session {sessid}...", extra={"spacing": "\n"}
                )
            # creates a session object to work with
            sess = session.Session(
                sessid, datadir, runtype=runtype, mouse_df=mouse_df) 
            # extracts necessary info for analysis
            sess.extract_info(
                full_table=full_table, fluor=fluor, dend=dend, roi=roi, run=run
                )
            if omit and sess.plane == "dend" and sess.dend != dend:
                logger.info(
                    f"Omitting session {sessid} ({dend} dendrites not found).")
                continue
            if pupil:
                sess.load_pup_data()
                    
            logger.info(f"Finished creating session {sessid}.")
            sessions.append(sess)

    return sessions


#############################################
def check_session(sess, roi=True, run=False, pupil=False, fluor="dff", 
                  dend="extr"):
    """
    check_session(session, analyspar)

    Checks whether required data is loaded, and returns session with required data loaded.

    Required args:
        - sess (Session): session object

    Optional args:
        - roi (bool)  : whether ROI information should be loaded
                        default: True
        - run (bool)  : whether running data should be loaded
                        default: False
        - pupil (bool): whether pupil data should be loaded
                        default: False
        - fluor (str) : fluorescence trace type
                        default: "dff"
        - dend (str)  : type of dendrites to use ("allen" or "extr")
                        default: "extr"
    
    Returns:
        - session (Session): session object, with required data loaded
    """

    sess = copy.deepcopy(sess)

    roi_loaded, run_loaded, pupil_loaded = sess.data_loaded()
    
    if roi and not(roi_loaded):
        sess.load_roi_info(fluor=fluor, dend=dend)
    
    if run and not(run_loaded):
        sess.load_run_data()
    
    if pupil and not(pupil_loaded):
        sess.load_pup_data()    
            
    return sess

            
#############################################
def get_nrois(nrois, n_bad_rois=0, n_bad_rois_dff=0, rem_bad=True, fluor="dff"):
    """
    get_nrois(nrois)

    Returns number of ROIs based on whether dF/F traces are used and ROIs with 
    NaN/Infs are removed from the data.

    Required args:
        - nrois (int)        : number of ROIs in the session
    
    Optional args:
        - n_bad_rois (int)    : number of ROIs with NaN/Infs in the raw data
        - n_bad_rois_dff (int): number of ROIs with NaN/Infs in the dF/F data
        - rem_bad (bool)     : if True, the number of ROIs with NaN/Infs is  
                               removed from the total
                               default: True
        - fluor (str)        : if "raw", number of ROIs is calculated with 
                               n_bad_rois. If "dff", it is calculated with 
                               n_bad_rois_dff  
                               default: "dff"

    Returns:
        - nrois (int): resulting number of ROIs
    """

    if rem_bad:
        if fluor == "dff":
            n_rem = n_bad_rois_dff
        elif fluor == "raw":
            n_rem = n_bad_rois
        else:
            gen_util.accepted_values_error("fluor", fluor, ["raw", "dff"])

        nrois = nrois - n_rem
    
    return nrois


#############################################
def get_sess_info(sessions, fluor="dff", add_none=False, incl_roi=True, 
                  return_df=False, rem_bad=False):
    """
    get_sess_info(sessions)

    Puts information from all sessions into a dictionary. Optionally allows 
    None sessions.

    Required args:
        - sessions (list): ordered list of Session objects
    
    Optional args:
        - fluor (str)    : specifies which bad_rois to include (for "dff" or 
                           "raw")
                           default: "dff"
        - add_none (bool): if True, None sessions are allowed and all values 
                           are filled with None
                           default: False
        - incl_roi (bool): if True, ROI information is included
                           default: True
        - rem_bad (bool) : if True, NaN/Inf ROI information is removed, and the 
                           number of subtracted from nrois
                           default: False

    Returns:
        - sess_info (dict or df): dictionary or dataframe containing 
                                  information from each session, as lists or 
                                  in dataframe rows, under the following keys 
                                  or columns
            "mouse_ns", "mouseids", "sess_ns", "sessids", "lines", "planes"
            if datatype == "roi":
                "nrois", "twop_fps"
            if not rem_bad: 
                "bad_rois_{}" (depending on fluor)
    """

    if return_df and add_none:
        raise ValueError("'add_none' cannot be True if 'return_df' is True.")

    if add_none and set(sessions) == {None}:
        logger.info("All None value sessions.")

    sess_info = dict()
    keys = ["mouse_ns", "mouseids", "sess_ns", "sessids", "lines", "planes"]
    if incl_roi:
        keys.extend(["nrois", "twop_fps"])
        if not rem_bad:
            keys.extend([f"bad_rois_{fluor}"])
    
    for key in keys:
        sess_info[key] = []

    sessions = gen_util.list_if_not(sessions)

    for _, sess in enumerate(sessions):
        if sess is None:
            if add_none:
                 for key in keys:
                     sess_info[key].append(None)
            else:
                raise RuntimeError("None sessions not allowed.")
        else:
            sess_info["mouse_ns"].append(sess.mouse_n)
            sess_info["mouseids"].append(sess.mouseid)
            sess_info["sess_ns"].append(sess.sess_n)
            sess_info["sessids"].append(sess.sessid)
            sess_info["lines"].append(sess.line)
            sess_info["planes"].append(sess.plane)
            if not incl_roi:
                continue
            
            nrois = sess.get_nrois(rem_bad=rem_bad, fluor=fluor)
            if not rem_bad:
                sess_info[f"bad_rois_{fluor}"].append(sess.get_bad_rois(fluor))

            sess_info["nrois"].append(nrois)
            sess_info["twop_fps"].append(sess.twop_fps)             

    if return_df:
        sess_info = pd.DataFrame.from_dict(sess_info)

    return sess_info


#############################################
def get_params(stimtype="both", visflow_dir="both", visflow_size=128, gabfr=0, 
               gabk=16, gab_ori="all"):
    """
    get_params()

    Gets and formats full parameters. For example, replaces "both" with a 
    list of parameter values, and sets parameters irrelevant to the stimulus
    of interest to "none".

    Required args:
        - stimtype  (str)            : stimulus to analyse 
                                       ("visflow", "gabors", "both")
        - visflow_dir (str or list)  : visual flow direction values 
                                       ("right", "left", "both")
        - visflow_size (int, str or list): visual flow square size values 
                                       (128, 256, "both")
        - gabfr (int, list or str)   : gabor frame value (0, 1, 2, 3, "0_3", 
                                                          [0, 3])
        - gabk (int, str or list)    : gabor kappa values (4, 16, "both")
        - gab_ori (int, str or list) : gabor orientation values 
                                       (0, 45, 90, 135, 180, 225 or "all")

    Returns:
        - visflow_dir (str or list) : visual flow direction values
        - visflow_size (int or list): visual flow square size values
        - gabfr (int or list)       : gabor frame values
        - gabk (int or list)        : gabor kappa values
        - gab_ori (int or list)     : gabor orientation values

    """

    # get all the parameters
    if gabk in ["both", "any", "all"]:
        gabk = get_param_vals("gabk")
    else:
        gabk = int(gabk)

    if gab_ori in ["any", "all"]:
        gab_ori = get_param_vals("gab_ori")
    elif not isinstance(gab_ori, list):
        gab_ori = int(gab_ori)

    if gabfr in ["any", "all"]:
        gabfr = get_param_vals("gabfr", gabfr_lett=False)
    elif not isinstance(gabfr, (list, int)) and gabfr.isdigit():
        gabfr = int(gabfr)

    if visflow_size in ["both", "any", "all"]:
        visflow_size = get_param_vals("visflow_size")
    else:
        visflow_size = int(visflow_size)

    if visflow_dir in ["both", "any", "all"]:
        visflow_dir = get_param_vals("visflow_dir")

    # set to "none" any parameters that are irrelevant
    if stimtype == "gabors":
        visflow_size = "none"
        visflow_dir = "none"
    elif stimtype == "visflow":
        gabfr = "none"
        gabk = "none"
        gab_ori = "none"
    elif stimtype != "both" and set(stimtype) != set(["gabors", "visflow"]):
        gen_util.accepted_values_error(
            "stim argument", stimtype, ["gabors", "visflow"])

    return visflow_dir, visflow_size, gabfr, gabk, gab_ori


#############################################
def get_visflow_screen_mouse_direc(direc="right"):
    """
    get_visflow_screen_mouse_direc()

    Returns direction for screen and mouse.

    Optional args:
        - direc (str): direction

    Returns:
        - direc (str): direction wrt screen and mouse
    """

    if "right" in direc or "temp" in direc:
        direc = "right (temp)"
    elif "left" in direc or "nasal" in direc:
        direc = "left (nasal)"
    elif "right" in direc and "nasal" in direc:
        raise ValueError(
            f"Invalid visual flow direction {direc}, "
            "as rightward motion is temp."
            )
    elif "left" in direc and "temp" in direc:
        raise ValueError(
            f"Invalid visual flow direction {direc}, "
            "as leftward motion is nasal."
            )
    else:
        raise ValueError(f"Visual flow direction {direc} not recognized.")

    return direc


#############################################
def gab_adjacent_gabfrs(gab_frs):
    """
    gab_adjacent_gabfrs(gab_frs)

    Returns whether at least 2 Gabor frames in list are consecutive.

    Required args:
        - gab_frs (list): list of Gabor frames (0, 1, 2, 3, 4)

    Returns:
        - adjacent (bool): True, if any 2 Gabor frames are adjacent. False, 
                           otherwise.
    """

    gab_frs = [int(gab_fr) for gab_fr in gab_frs]
    adjacent = (1 in np.diff(sorted(gab_frs)))

    return adjacent


#############################################
def get_reg_gab_ori(gab_ori_unexp):
    """
    get_reg_gab_ori(gab_ori_unexp)

    Returns mean Gabor orientation of the regular part of a sequence for the 
    specified unexpected frame orientation.

    Required args:
        - gab_ori_unexp (int): mean Gabor orientation of unexpected frames
    
    Returns:
        - gab_ori_reg (int): mean Gabor orientation of regular frame
    """

    gab_ori_reg = gab_ori_unexp - 90

    return gab_ori_reg


#############################################
def get_unexp_gab_ori(gab_ori_reg):
    """
    get_unexp_gab_ori(gab_ori_reg)

    Returns mean Gabor orientation of the unexpected part of a sequence for the 
    specified regular frame orientation.

    Required args:
        - gab_ori_reg (int): mean Gabor orientation of regular frames
    
    Returns:
        - gab_ori_unexp (int): mean Gabor orientation of unexpected frame
    """

    gab_ori_unexp = gab_ori_reg + 90

    return gab_ori_unexp


#############################################
def filter_gab_oris(gab_letters, gab_oris="any"):
    """
    filter_gab_oris(gab_letters)

    Returns Gabor orientations that fit with the specified frames.

    Required args:
        - gab_letters (list): Gabor letters for which to retrieve orientations

    Optional args:
        - gab_oris (list or str): Gabor orientations that can be included
                                  default: "any"
    
    Returns:
        - new_oris (list): list of orientations retained
    """

    gab_oris = get_params(gab_ori=gab_oris)[-1]

    if gab_letters.upper() == "U":
        poss_gab_oris = [90, 135, 180, 225]
    elif "U" in gab_letters.upper():
        poss_gab_oris = [0, 45, 90, 135, 180, 225]
    else:
        poss_gab_oris = [0, 45, 90, 135]
    
    new_oris = [ori for ori in gab_oris if ori in poss_gab_oris] 

    return new_oris


#############################################
def gab_oris_common_U(gab_oris):
    """
    gab_oris_common_U(gab_oris)

    Returns Gabor orientations that are common to U frames and other frames.

    Required args:
        - gab_oris (list): Gabor orientations that can be included

    Returns:
        - new_oris (list): orientations common to U and other frames
    """

    gab_oris = get_params(gab_ori=gab_oris)[-1]

    common_oris = [90, 135] # oris common to ABCD and U frames

    new_oris = [ori for ori in common_oris if ori in gab_oris]

    return new_oris


#############################################
def pilot_gab_omit(gabk):
    """
    pilot_gab_omit(gabk)

    Returns numbers of pilot mice to omit based on gabor kappa values to 
    include.

    Required args:
        - gabk (int or list): gabor kappa values (4, 16, [4, 16])
                                    
    Returns:
        - omit_mice (list): list IDs of mice to omit
    """

    gabk = gen_util.list_if_not(gabk)
    if 4 not in gabk:
        omit_mice = [3] # mouse 3 only got K=4
    elif 16 not in gabk:
        omit_mice = [4] # mouse 4 only got K=16
    else: 
        omit_mice = []
    return omit_mice


#############################################
def pilot_visflow_omit(visflow_dir, visflow_size):
    """
    pilot_visflow_omit(visflow_dir, visflow_size)

    Returns numbers of pilot mice to omit based on visual flow direction and 
    square size values to include.

    Required args:
        - visflow_dir (str or list) : visual flow direction values 
                                      ("right", "left")
        - visflow_size (int or list): visual flow square size values 
                                      (128, 256, [128, 256])
                                    
    Returns:
        - omit_mice (list): list IDs of mice to omit
    """

    visflow_dir = gen_util.list_if_not(visflow_dir)
    visflow_size = gen_util.list_if_not(visflow_size)
    omit_mice = []

    right_incl = len(list(filter(lambda x: "right" in x, visflow_dir)))
    left_incl = len(list(filter(lambda x: "left" in x, visflow_dir)))

    if not right_incl:
        # mouse 4 only got visflow_dir="right"
        omit_mice.extend([4]) 
        if 128 not in visflow_size:
            # mouse 3 only got visflow_dir="left" with visflow_size=128
            omit_mice.extend([3])
    elif not left_incl and 256 not in visflow_size:
        # mouse 3 only got visflow_dir="right" with visflow_size=256
        omit_mice.extend([3]) 
    return omit_mice

    
#############################################
def all_omit(stimtype="gabors", runtype="prod", visflow_dir="both", 
             visflow_size=128, gabk=16):
    """
    all_omit()

    Returns list of mice and sessions to omit, based on analysis parameters 
    (runtype, gabk, visflow_dir and visflow_size) and throws an error if the 
    parameter combination requested does not occur in the dataset.

    Required args:
        - stimtype  (str)           : stimulus to analyse ("visflow", "gabors")
        - runtype (str)             : runtype ("pilot", "prod")
        - visflow_dir (str or list) : visual flow direction values 
                                      ("right", "left")
        - visflow_size (int or list): visual flow square size values to include
                                      (128, 256, [128, 256])
        - gabk (int or list)        : gabor kappa values to include 
                                      (4, 16 or [4, 16])

    Returns:
        - omit_sess (list): sessions to omit
        - omit_mice (list): mice to omit
    """

    omit_sess = []
    omit_mice = []

    if runtype == "pilot":
        omit_sess = [714893802] # no data
        if stimtype == "gabors":
            omit_mice = pilot_gab_omit(gabk)
        elif stimtype == "visflow":
            omit_mice = pilot_visflow_omit(visflow_dir, visflow_size)

    elif runtype == "prod":
        if stimtype == "gabors": 
            if 16 not in gen_util.list_if_not(gabk):
                logger.warning("The production data only includes gabor "
                    "stimuli with kappa=16")
                omit_mice = list(range(1, 9)) # all
        elif stimtype == "visflow":
            if 128 not in gen_util.list_if_not(visflow_size):
                logger.warning("The production data only includes visual flow "
                    "stimuli with square size=128")
                omit_mice = list(range(1, 9)) # all

    return omit_sess, omit_mice


#############################################
def get_analysdir(mouse_n, sess_n, plane, fluor="dff", scale=True, 
                  stimtype="gabors", visflow_dir="right", visflow_size=128, 
                  gabk=16, comp="unexp", ctrl=False, shuffle=False):
    """
    get_analysdir(mouse_n, sess_n, plane)

    Generates the name of the general directory in which an analysis type is
    saved, based on analysis parameters.
    
    Required arguments:
        - mouse_n (int): mouse number
        - sess_n (int) : session number
        - plane (str)  : plane name

    Optional arguments:
        - fluor (str)               : fluorescence trace type
                                      default: "dff"
        - scale (str or bool)       : if scaling is used or type of scaling  
                                      used (e.g., "roi", "all", "none")
                                      default: None
        - stimtype (str)            : stimulus type
                                      default: "gabors"
        - visflow_dir (str)         : visual flow direction
                                      default: "right"
        - visflow_size (int or list): visual flow square size values to include
                                      (128, 256, [128, 256])
        - gabk (int or list)        : gabor kappa values to include 
                                      (4, 16 or [4, 16])        
        - comp (str)                : type of comparison
                                      default: "unexp"
        - ctrl (bool)               : whether analysis is a control for "exp"
                                      default: False
        - shuffle (bool)            : whether analysis is on shuffled data
                                      default: False

    Returns:
        - analysdir (str): name of directory to save analysis in, of the form:
                           "m{}_s{}_plane_stimtype_fluor_scaled_comp_shuffled"
    """

    from sess_util import sess_str_util

    stim_str = sess_str_util.stim_par_str(
        stimtype, visflow_dir, visflow_size, gabk, "file")

    scale_str = sess_str_util.scale_par_str(scale)
    shuff_str = sess_str_util.shuff_par_str(shuffle)
    ctrl_str  = sess_str_util.ctrl_par_str(ctrl)
    if comp is None:
        comp_str = ""
    else:
        comp_str = f"_{comp}"

    analysdir = (f"m{mouse_n}_s{sess_n}_{plane}_{stim_str}_{fluor}{scale_str}"
        f"{comp_str}{ctrl_str}{shuff_str}")

    return analysdir


#############################################
def get_params_from_str(param_str, no_lists=False):
    """
    get_params_from_str(param_str)

    Returns parameter information extracted from the parameter string.

    Required args:
        - param_str (str): String containing parameter information, of the form
                           "m{}_s{}_plane_stimtype_fluor_scaled_comp_shuffled",
                           though the order can be different as of plane
    
    Optional args:
        - no_lists (bool): if True, list parameters are replaced with a string, 
                           e.g. "both"
                           False
    Returns:
        - params (dict): parameter dictionary
            - visflow_dir (str or list) : visual flow direction parameter 
                                          ("right", "left", ["right", "left"] 
                                          or "none") 
            - visflow_size (int or list): visual flow square size parameter 
                                          (128, 256, [128, 256] or "none")
            - comp (str)                : comparison parameter ("exp", "AvB",
                                          "AvC", "BvC" or "DvU", None)
            - fluor (str)               : fluorescence parameter 
                                          ("raw" or "dff")
            - gabk (int or list)        : Gabor kappa parameter 
                                          (4, 16, [4, 16] or "none")
            - plane (str)               : plane ("soma" or "dend")
            - mouse_n (int)             : mouse number
            - sess_n (int)              : session number
            - scale (bool)              : scaling parameter
            - shuffle (bool)            : shuffle parameter
            - stimtype (str)            : stimulus type ("gabors" or "visflow")
    """

    params = dict()

    params["mouse_n"] = int(param_str.split("_")[0][1:])
    params["sess_n"]  = int(param_str.split("_")[1][1:])

    [params["visflow_dir"], params["visflow_size"], params["gabk"]] = \
        "none", "none", "none"
    
    if "gab" in param_str:
        params["stimtype"] = "gabors"
        params["gabk"] = 16
        if "both" in param_str:
            if no_lists:
                params["gabk"] = "both"
            else:
                params["gabk"] = get_param_vals("gabk")
        elif "gab4" in param_str:
            params["gabk"] = 4
    elif "visflow" in param_str:
        params["stimtype"] = "visflow"
        params["visflow_size"] = 128
        if "both" in param_str:
            if no_lists:
                params["visflow_size"] = "both"
            else:
                params["visflow_size"] = get_param_vals("visflow_size")
        elif "visflow256" in param_str:
            params["visflow_size"] = 256
        if no_lists:
            params["visflow_dir"] = "both"
        else:
            params["visflow_dir"] = ["right", "left"]
        if "right" in param_str:
            params["visflow_dir"] = "right"
        elif "left" in param_str:
            params["visflow_dir"] = "left"
    else:
        raise RuntimeError("Stimtype not identified.")

    if "soma" in param_str:
        params["plane"] = "soma"
    elif "dend" in param_str:
        params["plane"] = "dend"
    else:
        raise RuntimeError("plane not identified.")

    if "dff" in param_str:
        params["fluor"] = "dff"
    elif "raw" in param_str:
        params["fluor"] = "raw"
    else:
        raise RuntimeError("Fluorescence type not identified.")

    params["scale"] = False
    if "scale" in param_str:
        params["scale"] = True

    params["comp"] = None
    for comptype in ["exp", "AvB", "AvC", "BvC", "DvU"]:
        if comptype in param_str:
            params["comp"] = comptype

    if "shuffled" in param_str:
        params["shuffle"] = True
    else:
        params["shuffle"] = False

    return params


#############################################
def check_both_stimuli(sessions):
    """
    check_both_stimuli(sessions)

    Returns only sessions that have both stimuli ("gabors" and "visflow").
        
    Required args:
        - sessions (list) :  list of Session objects
    
    Returns:
        - keep_sess (list): list of retained Session objects
    """

    keep_sess = []
    all_stims = ["gabors", "visflow"]
    for sess in sessions:
        check = np.product([stim in sess.stimtypes for stim in all_stims])
        if check:
            keep_sess.append(sess)

    return keep_sess

