"""
signif_grps.py

This module contains functions to run analyses of ROI groups showing
significant differences between unexpected and expected sequences in the data 
generated by the Allen Institute OpenScope experiments for the Credit 
Assignment Project.

Authors: Colleen Gillon

Date: October, 2018

Note: this code uses python 3.7.

"""

import numpy as np

from util import gen_util, logger_util, math_util, rand_util


TAB = "    "


logger = logger_util.get_module_logger(name=__name__)


#############################################
def sep_grps(sign_rois, nrois, grps="all", tails="2", add_exp=False):
    """
    sep_grps(sign_rois, nrois)

    Separate ROIs into groups based on whether their first/last quantile was
    significant in a specific tail.

    Required args:
        - sign_rois (nested list): list of significant ROIs, structured as:
                                       quantile (x tail) 
        - nrois (int)            : total number of ROIs in data (signif or not)
    Optional args:
        - grps (str or list): set of groups or list of sets of groups to 
                              return, e.g., "all", "change", "no_change", 
                              "reduc", "incr"
                              default: "all"
        - tails (str)       : tail(s) used in analysis: "hi", "lo" or 2
                              default: 2
        - add_exp (bool)    : if True, group of ROIs showing no significance in 
                              either is included in the groups returned
                              default: False 
    Returns:
        - roi_grps (list)   : lists structured as follows:
                              if grp parameter includes only one set, 
                                  ROIs per roi group
                              otherwise: sets x roi grps
                              numbers included in the group
        - grp_names (list)  : if grp parameter includes only one set, list of 
                              names of roi grps (order preserved)
                              otherwise: list of sublists per set, each 
                              containing names of roi grps per set
    """

    grps = gen_util.list_if_not(grps)
    # get ROI numbers for each group
    if tails in ["hi", "lo"]:
        # sign_rois[first/last]
        all_rois  = list(range(nrois))
        unexp_unexp = list(set(sign_rois[0]) & set(sign_rois[1]))
        unexp_exp  = list(set(sign_rois[0]) - set(sign_rois[1]))
        exp_unexp  = list(set(sign_rois[1]) - set(sign_rois[0]))
        exp_exp   = list(
            set(all_rois) - set(unexp_unexp) - set(unexp_exp) - set(exp_unexp))
        # to store stats
        roi_grps  = [unexp_unexp, unexp_exp, exp_unexp, exp_exp]
        grp_names = ["unexp_unexp", "unexp_exp", "exp_unexp", "exp_exp"]
        exp_ind = 3
        grp_inds = []
        for i, g in enumerate(grps):
            if g == "all":
                grp_ind = list(range(len(roi_grps)))
            elif g == "change":
                grp_ind = [1, 2]
            elif g == "no_change":
                grp_ind = [0, 3]
            elif g == "reduc":
                grp_ind = [1]
            elif g == "incr":
                grp_ind = [2]
            else:
                gen_util.accepted_values_error(
                    "grps", g, ["all", "change", "no_change", "reduc", "incr"])
            if add_exp and exp_ind not in grp_ind:
                grp_ind.extend([exp_ind])
            grp_inds.append(sorted(grp_ind))

    elif str(tails) == "2":
        # sign_rois[first/last][lo/up]
        all_rois = list(range(nrois))         
        unexp_up_unexp_up = list(set(sign_rois[0][1]) & set(sign_rois[1][1]))
        unexp_up_unexp_lo = list(set(sign_rois[0][1]) & set(sign_rois[1][0]))
        unexp_lo_unexp_up = list(set(sign_rois[0][0]) & set(sign_rois[1][1]))
        unexp_lo_unexp_lo = list(set(sign_rois[0][0]) & set(sign_rois[1][0]))

        unexp_up_exp = list(
            (set(sign_rois[0][1]) - set(sign_rois[1][1]) - \
                set(sign_rois[1][0])))
        unexp_lo_exp = list(
            (set(sign_rois[0][0]) - set(sign_rois[1][1]) - \
                set(sign_rois[1][0])))
        
        exp_unexp_up = list(
            (set(sign_rois[1][1]) - set(sign_rois[0][1]) - \
                set(sign_rois[0][0])))
        exp_unexp_lo = list(
            (set(sign_rois[1][0]) - set(sign_rois[0][1]) - \
                set(sign_rois[0][0])))
        
        exp_exp = list(
            (set(all_rois) - set(sign_rois[0][1]) - set(sign_rois[1][1]) - \
                set(sign_rois[0][0]) - set(sign_rois[1][0])))
        # to store stats
        roi_grps = [unexp_up_unexp_up, unexp_up_unexp_lo, unexp_lo_unexp_up, 
            unexp_lo_unexp_lo, unexp_up_exp, unexp_lo_exp, exp_unexp_up, 
            exp_unexp_lo, exp_exp]
        exp_ind = 8 # index of exp_exp
        # group names 
        grp_names = ["unexp-up_unexp-up", "unexp-up_unexp-lo", "unexp-lo_unexp-up", 
            "unexp-lo_unexp-lo", "unexp-up_exp", "unexp-lo_exp", "exp_unexp-up", 
            "exp_unexp-lo", "exp_exp"]
        exp_ind = 8
        grp_inds = []
        for i, g in enumerate(grps):
            if g == "all":
                grp_ind = list(range(len(roi_grps)))
            elif g == "change":
                grp_ind = [1, 2, 4, 5, 6, 7]
            elif g == "no_change":
                grp_ind = [0, 3, 8]
            elif g == "reduc":
                grp_ind = [1, 4, 7]
            elif g == "incr":
                grp_ind = [2, 5, 6]
            else:
                gen_util.accepted_values_error(
                    "grps", grps, 
                    ["all", "change", "no_change", "reduc", "incr"])
            if add_exp and exp_ind not in grp_ind:
                grp_ind.extend([exp_ind])
            grp_inds.append(sorted(grp_ind))

    all_roi_grps = [[roi_grps[i] for i in grp_ind] for grp_ind in grp_inds]
    all_grp_names = [[grp_names[i] for i in grp_ind] for grp_ind in grp_inds]
    if len(grps) == 1:
        all_roi_grps = all_roi_grps[0]
        all_grp_names = all_grp_names[0] 

    return all_roi_grps, all_grp_names


#############################################
def grp_stats(integ_stats, grps, plot_vals="both", op="diff", stats="mean", 
              error="std", scale=False):
    """
    grp_stats(integ_stats, grps)

    Calculate statistics (e.g. mean + sem) across quantiles for each group 
    and session.

    Required args:
        - integ_stats (list): list of 3D arrays of mean/medians of integrated
                              sequences, for each session structured as:
                                 unexp if by_exp x
                                 quantiles x
                                 ROIs if byroi
        - grps (list)       : list of sublists per session, each containing
                              sublists per roi grp with ROI numbers included in 
                              the group: session x roi_grp
    Optional args:
        - plot_vals (str): which values to return ("unexp", "exp" or "both")
                           default: "both"
        - op (str)       : operation to use to compare groups, if plot_vals
                           is "both"
                           i.e. "diff": grp1-grp2, or "ratio": grp1/grp2
                           default: "diff"
        - stats (str)    : statistic parameter, i.e. "mean" or "median"
                           default: "mean"
        - error (str)    : error statistic parameter, i.e. "std" or "sem"
                           default: "std"
        - scale (bool)   : if True, data is scaled using first quantile
    Returns:
        - all_grp_st (4D array): array of group stats (mean/median, error) 
                                 structured as:
                                  session x quantile x grp x stat 
        - all_ns (2D array)    : array of group ns, structured as:
                                  session x grp
    """

    n_sesses = len(integ_stats)
    n_quants = integ_stats[0].shape[1]
    n_stats  = 2 + (stats == "median" and error == "std")
    n_grps   = len(grps[0])

    all_grp_st = np.empty([n_sesses, n_quants, n_grps, n_stats])
    all_ns = np.empty([n_sesses, n_grps], dtype=int)

    for i, [sess_data, sess_grps] in enumerate(zip(integ_stats, grps)):
        # calculate diff/ratio or retrieve exp/unexp 
        if plot_vals in ["exp", "unexp"]:
            op = ["exp", "unexp"].index(plot_vals)
        sess_data = math_util.calc_op(sess_data, op, dim=0)
        for g, grp in enumerate(sess_grps):
            all_ns[i, g] = len(grp)
            all_grp_st[i, :, g, :] = np.nan
            if len(grp) != 0:
                grp_data = sess_data[:, grp]
                if scale:
                    grp_data, _ = math_util.scale_data(
                        grp_data, axis=0, pos=0, sc_type="unit")
                all_grp_st[i, :, g] = math_util.get_stats(
                    grp_data, stats, error, axes=1).T

    return all_grp_st, all_ns


#############################################
def grp_traces_by_qu_unexp_sess(trace_data, analyspar, roigrppar, all_roi_grps):

    """
    grp_traces_by_qu_unexp_sess(trace_data, analyspar, roigrppar, all_roi_grps)
                               
    Required args:
        - trace_data (list)    : list of 4D array of mean/medians traces 
                                 for each session, structured as:
                                    unexp x quantiles x ROIs x frames
        - analyspar (AnalysPar): named tuple containing analysis parameters
        - roigrppar (RoiGrpPar): named tuple containing roi grouping parameters
        - all_roi_grps (list)  : list of sublists per session, each containing
                                 sublists per roi grp with ROI numbers included 
                                 in the group: session x roi_grp

    Returns:
        - grp_stats (list): nested list of statistics for ROI groups 
                            structured as:
                                sess x qu x ROI grp x stats x frame
    """

    # calculate diff/ratio or retrieve exp/unexp 
    op = roigrppar.op
    if roigrppar.plot_vals in ["exp", "unexp"]:
        op = ["exp", "unexp"].index(roigrppar.plot_vals)
    data_me = [math_util.calc_op(sess_me, op, dim=0) for sess_me in trace_data]
    
    n_sesses = len(data_me)
    n_quants = data_me[0].shape[0]
    n_stats  = 2 + (analyspar.stats == "median" and analyspar.error == "std")

    n_frames = [me.shape[2] for me in data_me]

    # sess x quantile (first/last) x ROI grp
    empties = [np.full([n_stats, n_fr], np.nan) for n_fr in n_frames]
    grp_stats = [[[] for _ in range(n_quants)] for _ in range(n_sesses)]
    for i, sess in enumerate(data_me):
        for q, quant in enumerate(sess): 
            for g, grp_rois in enumerate(all_roi_grps[i]):
                # leave NaNs if no ROIs in group
                if len(grp_rois) != 0:
                    grp_st = math_util.get_stats(
                        quant[grp_rois], analyspar.stats, analyspar.error, 
                        axes=0)
                else:
                    grp_st = empties[i]
                grp_stats[i][q].append(grp_st.tolist())

    return grp_stats


#############################################
def get_signif_rois(integ_data, permpar, stats="mean", op="diff", nanpol=None, 
                    log_rois=True):
    """
    get_signif_rois(integ_data, permpar)

    Identifies ROIs showing significant unexpected responses in specified quantiles,
    groups accordingly and retrieves statistics for each group.

    Required args:
        - integ_data (list): list of 2D array of ROI activity integrated 
                             across frames.
                                unexp (0, 1) x array[ROI x sequences]
        - permpar (PermPar): named tuple containing permutation parameters
                             (multcomp does not apply to identifiying 
                             significant ROIs)

    Optional args:
        - stats (str)    : statistic parameter, i.e. "mean" or "median"
                           default: "mean"
        - op (str)       : operation to identify significant ROIs
                           default: "diff"
        - nanpol (str)   : policy for NaNs, "omit" or None when taking 
                           statistics
                           default: None
        - log_rois (bool): if True, the indices of significant ROIs and
                           their actual difference values are logged

    Returns: 
        - sign_rois (list): list of ROIs showing significant differences, or 
                            list of lists if 2-tailed analysis [lo, up].
    """
    
    n_exp = integ_data[1].shape[1]
    # calculate real values (average across seqs)
    data = [math_util.mean_med(integ_data[0], stats, axis=1, nanpol=nanpol), 
        math_util.mean_med(integ_data[1], stats, axis=1, nanpol=nanpol)]
    # ROI x seq
    qu_data_res = math_util.calc_op(np.asarray(data), op, dim=0)
    # concatenate unexp and exp from quantile
    qu_data_all = np.concatenate(integ_data, axis=1)
    # run permutation to identify significant ROIs
    all_rand_res = rand_util.permute_diff_ratio(
        qu_data_all, n_exp, permpar.n_perms, stats, nanpol, op)
    sign_rois = rand_util.id_elem(
        all_rand_res, qu_data_res, permpar.tails, permpar.p_val, 
        log_elems=log_rois)
    return sign_rois


#############################################
def signif_rois_by_grp_sess(sessids, integ_data, permpar, roigrppar,  
                            qu_labs=["first quant", "last quant"], 
                            stats="mean", nanpol=None):
    """
    signif_rois_by_grp_sess(sessids, integ_data, permpar, roigrppar)

    Identifies ROIs showing significant unexpected responses in specified quantiles,
    groups accordingly and retrieves statistics for each group.

    Required args:
        - sessids (list)       : list of Session IDs
        - integ_data (list)    : list of 2D array of ROI activity integrated 
                                 across frames. Should only include quantiles
                                 retained for analysis:
                                    sess x unexp (0, 1) x quantiles x 
                                    array[ROI x sequences]
        - permpar (PermPar)    : named tuple containing permutation parameters
        - roigrppar (RoiGrpPar): named tuple containing roi grouping parameters

    Optional args:
        - qu_labs (list): quantiles being compared
                          default: ["first Q", "last Q"]
        - stats (str)   : statistic parameter, i.e. "mean" or "median"
                          default: "mean"
        - nanpol (str)  : policy for NaNs, "omit" or None when taking statistics
                          default: None

    Returns: 
        - all_roi_grps (list)   : list of sublists per session, containing ROI 
                                  numbers included in each group, structured as 
                                  follows:
                                      if sets of groups are passed: 
                                          session x set x roi_grp
                                      if one group is passed: 
                                          session x roi_grp
        - grp_names (list)      : list of names of the ROI groups in roi grp 
                                  lists (order preserved)
    """

    if len(qu_labs) != 2:
        raise ValueError("Identifying significant ROIs is only implemented "
            "for 2 quantiles.")

    logger.info("Identifying ROIs showing significant unexpected responses in "
        f"{qu_labs[0].capitalize()} and/or {qu_labs[1].capitalize()}.", 
        extra={"spacing": "\n"})

    all_roi_grps = []


    for sessid, sess_data in zip(sessids, integ_data):
        logger.info(f"Session {sessid}", extra={"spacing": "\n"})
        sess_rois = []
        nrois   = sess_data[0][0].shape[0]
        for q, q_lab in enumerate(qu_labs):
            logger.info(f"{q_lab.capitalize()}", extra={"spacing": TAB})
            sign_rois = get_signif_rois(
                [sess_data[0][q], sess_data[1][q]], permpar, stats, 
                roigrppar.op, nanpol)
            sess_rois.append(sign_rois)
            
        grps = gen_util.list_if_not(roigrppar.grps)

        if len(grps) == 1:
            roi_grps, grp_names = sep_grps(
                sess_rois, nrois=nrois, grps=roigrppar.grps, 
                tails=permpar.tails, add_exp=roigrppar.add_exp)
        else:
            roi_grps = []
            for grp_set in roigrppar.grps:
                roi_grps_set, _ = sep_grps(
                    sess_rois, nrois=nrois, grps=grp_set, tails=permpar.tails, 
                    add_exp=False)
                
                # flat, without duplicates
                flat_grp = sorted(
                    list(set([roi for grp in roi_grps_set for roi in grp])))
                roi_grps.append(flat_grp)
                
            grp_names = roigrppar.grps
        
        all_roi_grps.append(roi_grps)
    
    return all_roi_grps, grp_names

